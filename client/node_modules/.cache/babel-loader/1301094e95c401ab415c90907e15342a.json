{"ast":null,"code":"import _assertThisInitialized from \"C:\\\\Users\\\\ASUS VivoBook\\\\Desktop\\\\PI - Copie\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _toConsumableArray from \"C:\\\\Users\\\\ASUS VivoBook\\\\Desktop\\\\PI - Copie\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\ASUS VivoBook\\\\Desktop\\\\PI - Copie\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\ASUS VivoBook\\\\Desktop\\\\PI - Copie\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\ASUS VivoBook\\\\Desktop\\\\PI - Copie\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _classCallCheck from \"C:\\\\Users\\\\ASUS VivoBook\\\\Desktop\\\\PI - Copie\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\ASUS VivoBook\\\\Desktop\\\\PI - Copie\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nimport { createPlugin } from '@fullcalendar/core/index.js';\nimport { config, Emitter, elementClosest, applyStyle, whenTransitionDone, removeElement, ScrollController, ElementScrollController, computeInnerRect, WindowScrollController, ElementDragging, preventSelection, preventContextMenu, allowSelection, allowContextMenu, computeRect, getClippingParents, pointInsideRect, constrainPoint, intersectRects, getRectCenter, diffPoints, mapHash, rangeContainsRange, isDateSpansEqual, Interaction, interactionSettingsToStore, isDateSelectionValid, enableCursor, disableCursor, triggerDateSelect, compareNumbers, getElSeg, getRelevantEvents, EventImpl, createEmptyEventStore, applyMutationToEventStore, isInteractionValid, buildEventApis, interactionSettingsStore, startOfDay, diffDates, createDuration, getEventTargetViaRoot, identity, eventTupleToStore, parseDragMeta, elementMatches, refineEventDef, parseEventDef, getDefaultEventEnd, createEventInstance, BASE_OPTION_DEFAULTS } from '@fullcalendar/core/internal.js';\nconfig.touchMouseIgnoreWait = 500;\nvar ignoreMouseDepth = 0;\nvar listenerCnt = 0;\nvar isWindowTouchMoveCancelled = false;\n/*\nUses a \"pointer\" abstraction, which monitors UI events for both mouse and touch.\nTracks when the pointer \"drags\" on a certain element, meaning down+move+up.\n\nAlso, tracks if there was touch-scrolling.\nAlso, can prevent touch-scrolling from happening.\nAlso, can fire pointermove events when scrolling happens underneath, even when no real pointer movement.\n\nemits:\n- pointerdown\n- pointermove\n- pointerup\n*/\nvar PointerDragging = /*#__PURE__*/function () {\n  function PointerDragging(containerEl) {\n    var _this = this;\n    _classCallCheck(this, PointerDragging);\n    this.subjectEl = null;\n    // options that can be directly assigned by caller\n    this.selector = ''; // will cause subjectEl in all emitted events to be this element\n    this.handleSelector = '';\n    this.shouldIgnoreMove = false;\n    this.shouldWatchScroll = true; // for simulating pointermove on scroll\n    // internal states\n    this.isDragging = false;\n    this.isTouchDragging = false;\n    this.wasTouchScroll = false;\n    // Mouse\n    // ----------------------------------------------------------------------------------------------------\n    this.handleMouseDown = function (ev) {\n      if (!_this.shouldIgnoreMouse() && isPrimaryMouseButton(ev) && _this.tryStart(ev)) {\n        var pev = _this.createEventFromMouse(ev, true);\n        _this.emitter.trigger('pointerdown', pev);\n        _this.initScrollWatch(pev);\n        if (!_this.shouldIgnoreMove) {\n          document.addEventListener('mousemove', _this.handleMouseMove);\n        }\n        document.addEventListener('mouseup', _this.handleMouseUp);\n      }\n    };\n    this.handleMouseMove = function (ev) {\n      var pev = _this.createEventFromMouse(ev);\n      _this.recordCoords(pev);\n      _this.emitter.trigger('pointermove', pev);\n    };\n    this.handleMouseUp = function (ev) {\n      document.removeEventListener('mousemove', _this.handleMouseMove);\n      document.removeEventListener('mouseup', _this.handleMouseUp);\n      _this.emitter.trigger('pointerup', _this.createEventFromMouse(ev));\n      _this.cleanup(); // call last so that pointerup has access to props\n    };\n    // Touch\n    // ----------------------------------------------------------------------------------------------------\n    this.handleTouchStart = function (ev) {\n      if (_this.tryStart(ev)) {\n        _this.isTouchDragging = true;\n        var pev = _this.createEventFromTouch(ev, true);\n        _this.emitter.trigger('pointerdown', pev);\n        _this.initScrollWatch(pev);\n        // unlike mouse, need to attach to target, not document\n        // https://stackoverflow.com/a/45760014\n        var targetEl = ev.target;\n        if (!_this.shouldIgnoreMove) {\n          targetEl.addEventListener('touchmove', _this.handleTouchMove);\n        }\n        targetEl.addEventListener('touchend', _this.handleTouchEnd);\n        targetEl.addEventListener('touchcancel', _this.handleTouchEnd); // treat it as a touch end\n        // attach a handler to get called when ANY scroll action happens on the page.\n        // this was impossible to do with normal on/off because 'scroll' doesn't bubble.\n        // http://stackoverflow.com/a/32954565/96342\n        window.addEventListener('scroll', _this.handleTouchScroll, true);\n      }\n    };\n    this.handleTouchMove = function (ev) {\n      var pev = _this.createEventFromTouch(ev);\n      _this.recordCoords(pev);\n      _this.emitter.trigger('pointermove', pev);\n    };\n    this.handleTouchEnd = function (ev) {\n      if (_this.isDragging) {\n        // done to guard against touchend followed by touchcancel\n        var targetEl = ev.target;\n        targetEl.removeEventListener('touchmove', _this.handleTouchMove);\n        targetEl.removeEventListener('touchend', _this.handleTouchEnd);\n        targetEl.removeEventListener('touchcancel', _this.handleTouchEnd);\n        window.removeEventListener('scroll', _this.handleTouchScroll, true); // useCaptured=true\n        _this.emitter.trigger('pointerup', _this.createEventFromTouch(ev));\n        _this.cleanup(); // call last so that pointerup has access to props\n        _this.isTouchDragging = false;\n        startIgnoringMouse();\n      }\n    };\n    this.handleTouchScroll = function () {\n      _this.wasTouchScroll = true;\n    };\n    this.handleScroll = function (ev) {\n      if (!_this.shouldIgnoreMove) {\n        var pageX = window.pageXOffset - _this.prevScrollX + _this.prevPageX;\n        var pageY = window.pageYOffset - _this.prevScrollY + _this.prevPageY;\n        _this.emitter.trigger('pointermove', {\n          origEvent: ev,\n          isTouch: _this.isTouchDragging,\n          subjectEl: _this.subjectEl,\n          pageX: pageX,\n          pageY: pageY,\n          deltaX: pageX - _this.origPageX,\n          deltaY: pageY - _this.origPageY\n        });\n      }\n    };\n    this.containerEl = containerEl;\n    this.emitter = new Emitter();\n    containerEl.addEventListener('mousedown', this.handleMouseDown);\n    containerEl.addEventListener('touchstart', this.handleTouchStart, {\n      passive: true\n    });\n    listenerCreated();\n  }\n  _createClass(PointerDragging, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.containerEl.removeEventListener('mousedown', this.handleMouseDown);\n      this.containerEl.removeEventListener('touchstart', this.handleTouchStart, {\n        passive: true\n      });\n      listenerDestroyed();\n    }\n  }, {\n    key: \"tryStart\",\n    value: function tryStart(ev) {\n      var subjectEl = this.querySubjectEl(ev);\n      var downEl = ev.target;\n      if (subjectEl && (!this.handleSelector || elementClosest(downEl, this.handleSelector))) {\n        this.subjectEl = subjectEl;\n        this.isDragging = true; // do this first so cancelTouchScroll will work\n        this.wasTouchScroll = false;\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      isWindowTouchMoveCancelled = false;\n      this.isDragging = false;\n      this.subjectEl = null;\n      // keep wasTouchScroll around for later access\n      this.destroyScrollWatch();\n    }\n  }, {\n    key: \"querySubjectEl\",\n    value: function querySubjectEl(ev) {\n      if (this.selector) {\n        return elementClosest(ev.target, this.selector);\n      }\n      return this.containerEl;\n    }\n  }, {\n    key: \"shouldIgnoreMouse\",\n    value: function shouldIgnoreMouse() {\n      return ignoreMouseDepth || this.isTouchDragging;\n    } // can be called by user of this class, to cancel touch-based scrolling for the current drag\n  }, {\n    key: \"cancelTouchScroll\",\n    value: function cancelTouchScroll() {\n      if (this.isDragging) {\n        isWindowTouchMoveCancelled = true;\n      }\n    } // Scrolling that simulates pointermoves\n    // ----------------------------------------------------------------------------------------------------\n  }, {\n    key: \"initScrollWatch\",\n    value: function initScrollWatch(ev) {\n      if (this.shouldWatchScroll) {\n        this.recordCoords(ev);\n        window.addEventListener('scroll', this.handleScroll, true); // useCapture=true\n      }\n    }\n  }, {\n    key: \"recordCoords\",\n    value: function recordCoords(ev) {\n      if (this.shouldWatchScroll) {\n        this.prevPageX = ev.pageX;\n        this.prevPageY = ev.pageY;\n        this.prevScrollX = window.pageXOffset;\n        this.prevScrollY = window.pageYOffset;\n      }\n    }\n  }, {\n    key: \"destroyScrollWatch\",\n    value: function destroyScrollWatch() {\n      if (this.shouldWatchScroll) {\n        window.removeEventListener('scroll', this.handleScroll, true); // useCaptured=true\n      }\n    } // Event Normalization\n    // ----------------------------------------------------------------------------------------------------\n  }, {\n    key: \"createEventFromMouse\",\n    value: function createEventFromMouse(ev, isFirst) {\n      var deltaX = 0;\n      var deltaY = 0;\n      // TODO: repeat code\n      if (isFirst) {\n        this.origPageX = ev.pageX;\n        this.origPageY = ev.pageY;\n      } else {\n        deltaX = ev.pageX - this.origPageX;\n        deltaY = ev.pageY - this.origPageY;\n      }\n      return {\n        origEvent: ev,\n        isTouch: false,\n        subjectEl: this.subjectEl,\n        pageX: ev.pageX,\n        pageY: ev.pageY,\n        deltaX: deltaX,\n        deltaY: deltaY\n      };\n    }\n  }, {\n    key: \"createEventFromTouch\",\n    value: function createEventFromTouch(ev, isFirst) {\n      var touches = ev.touches;\n      var pageX;\n      var pageY;\n      var deltaX = 0;\n      var deltaY = 0;\n      // if touch coords available, prefer,\n      // because FF would give bad ev.pageX ev.pageY\n      if (touches && touches.length) {\n        pageX = touches[0].pageX;\n        pageY = touches[0].pageY;\n      } else {\n        pageX = ev.pageX;\n        pageY = ev.pageY;\n      }\n      // TODO: repeat code\n      if (isFirst) {\n        this.origPageX = pageX;\n        this.origPageY = pageY;\n      } else {\n        deltaX = pageX - this.origPageX;\n        deltaY = pageY - this.origPageY;\n      }\n      return {\n        origEvent: ev,\n        isTouch: true,\n        subjectEl: this.subjectEl,\n        pageX: pageX,\n        pageY: pageY,\n        deltaX: deltaX,\n        deltaY: deltaY\n      };\n    }\n  }]);\n  return PointerDragging;\n}(); // Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)\nfunction isPrimaryMouseButton(ev) {\n  return ev.button === 0 && !ev.ctrlKey;\n}\n// Ignoring fake mouse events generated by touch\n// ----------------------------------------------------------------------------------------------------\nfunction startIgnoringMouse() {\n  ignoreMouseDepth += 1;\n  setTimeout(function () {\n    ignoreMouseDepth -= 1;\n  }, config.touchMouseIgnoreWait);\n}\n// We want to attach touchmove as early as possible for Safari\n// ----------------------------------------------------------------------------------------------------\nfunction listenerCreated() {\n  listenerCnt += 1;\n  if (listenerCnt === 1) {\n    window.addEventListener('touchmove', onWindowTouchMove, {\n      passive: false\n    });\n  }\n}\nfunction listenerDestroyed() {\n  listenerCnt -= 1;\n  if (!listenerCnt) {\n    window.removeEventListener('touchmove', onWindowTouchMove, {\n      passive: false\n    });\n  }\n}\nfunction onWindowTouchMove(ev) {\n  if (isWindowTouchMoveCancelled) {\n    ev.preventDefault();\n  }\n}\n\n/*\nAn effect in which an element follows the movement of a pointer across the screen.\nThe moving element is a clone of some other element.\nMust call start + handleMove + stop.\n*/\nvar ElementMirror = /*#__PURE__*/function () {\n  function ElementMirror() {\n    _classCallCheck(this, ElementMirror);\n    this.isVisible = false; // must be explicitly enabled\n    this.sourceEl = null;\n    this.mirrorEl = null;\n    this.sourceElRect = null; // screen coords relative to viewport\n    // options that can be set directly by caller\n    this.parentNode = document.body; // HIGHLY SUGGESTED to set this to sidestep ShadowDOM issues\n    this.zIndex = 9999;\n    this.revertDuration = 0;\n  }\n  _createClass(ElementMirror, [{\n    key: \"start\",\n    value: function start(sourceEl, pageX, pageY) {\n      this.sourceEl = sourceEl;\n      this.sourceElRect = this.sourceEl.getBoundingClientRect();\n      this.origScreenX = pageX - window.pageXOffset;\n      this.origScreenY = pageY - window.pageYOffset;\n      this.deltaX = 0;\n      this.deltaY = 0;\n      this.updateElPosition();\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(pageX, pageY) {\n      this.deltaX = pageX - window.pageXOffset - this.origScreenX;\n      this.deltaY = pageY - window.pageYOffset - this.origScreenY;\n      this.updateElPosition();\n    } // can be called before start\n  }, {\n    key: \"setIsVisible\",\n    value: function setIsVisible(bool) {\n      if (bool) {\n        if (!this.isVisible) {\n          if (this.mirrorEl) {\n            this.mirrorEl.style.display = '';\n          }\n          this.isVisible = bool; // needs to happen before updateElPosition\n          this.updateElPosition(); // because was not updating the position while invisible\n        }\n      } else if (this.isVisible) {\n        if (this.mirrorEl) {\n          this.mirrorEl.style.display = 'none';\n        }\n        this.isVisible = bool;\n      }\n    } // always async\n  }, {\n    key: \"stop\",\n    value: function stop(needsRevertAnimation, callback) {\n      var _this2 = this;\n      var done = function done() {\n        _this2.cleanup();\n        callback();\n      };\n      if (needsRevertAnimation && this.mirrorEl && this.isVisible && this.revertDuration && (\n      // if 0, transition won't work\n      this.deltaX || this.deltaY) // if same coords, transition won't work\n      ) {\n        this.doRevertAnimation(done, this.revertDuration);\n      } else {\n        setTimeout(done, 0);\n      }\n    }\n  }, {\n    key: \"doRevertAnimation\",\n    value: function doRevertAnimation(callback, revertDuration) {\n      var mirrorEl = this.mirrorEl;\n      var finalSourceElRect = this.sourceEl.getBoundingClientRect(); // because autoscrolling might have happened\n      mirrorEl.style.transition = 'top ' + revertDuration + 'ms,' + 'left ' + revertDuration + 'ms';\n      applyStyle(mirrorEl, {\n        left: finalSourceElRect.left,\n        top: finalSourceElRect.top\n      });\n      whenTransitionDone(mirrorEl, function () {\n        mirrorEl.style.transition = '';\n        callback();\n      });\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      if (this.mirrorEl) {\n        removeElement(this.mirrorEl);\n        this.mirrorEl = null;\n      }\n      this.sourceEl = null;\n    }\n  }, {\n    key: \"updateElPosition\",\n    value: function updateElPosition() {\n      if (this.sourceEl && this.isVisible) {\n        applyStyle(this.getMirrorEl(), {\n          left: this.sourceElRect.left + this.deltaX,\n          top: this.sourceElRect.top + this.deltaY\n        });\n      }\n    }\n  }, {\n    key: \"getMirrorEl\",\n    value: function getMirrorEl() {\n      var sourceElRect = this.sourceElRect;\n      var mirrorEl = this.mirrorEl;\n      if (!mirrorEl) {\n        mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true); // cloneChildren=true\n        // we don't want long taps or any mouse interaction causing selection/menus.\n        // would use preventSelection(), but that prevents selectstart, causing problems.\n        mirrorEl.style.userSelect = 'none';\n        mirrorEl.classList.add('fc-event-dragging');\n        applyStyle(mirrorEl, {\n          position: 'fixed',\n          zIndex: this.zIndex,\n          visibility: '',\n          boxSizing: 'border-box',\n          width: sourceElRect.right - sourceElRect.left,\n          height: sourceElRect.bottom - sourceElRect.top,\n          right: 'auto',\n          bottom: 'auto',\n          margin: 0\n        });\n        this.parentNode.appendChild(mirrorEl);\n      }\n      return mirrorEl;\n    }\n  }]);\n  return ElementMirror;\n}();\n/*\nIs a cache for a given element's scroll information (all the info that ScrollController stores)\nin addition the \"client rectangle\" of the element.. the area within the scrollbars.\n\nThe cache can be in one of two modes:\n- doesListening:false - ignores when the container is scrolled by someone else\n- doesListening:true - watch for scrolling and update the cache\n*/\nvar ScrollGeomCache = /*#__PURE__*/function (_ScrollController) {\n  _inherits(ScrollGeomCache, _ScrollController);\n  function ScrollGeomCache(scrollController, doesListening) {\n    var _this3;\n    _classCallCheck(this, ScrollGeomCache);\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(ScrollGeomCache).call(this));\n    _this3.handleScroll = function () {\n      _this3.scrollTop = _this3.scrollController.getScrollTop();\n      _this3.scrollLeft = _this3.scrollController.getScrollLeft();\n      _this3.handleScrollChange();\n    };\n    _this3.scrollController = scrollController;\n    _this3.doesListening = doesListening;\n    _this3.scrollTop = _this3.origScrollTop = scrollController.getScrollTop();\n    _this3.scrollLeft = _this3.origScrollLeft = scrollController.getScrollLeft();\n    _this3.scrollWidth = scrollController.getScrollWidth();\n    _this3.scrollHeight = scrollController.getScrollHeight();\n    _this3.clientWidth = scrollController.getClientWidth();\n    _this3.clientHeight = scrollController.getClientHeight();\n    _this3.clientRect = _this3.computeClientRect(); // do last in case it needs cached values\n    if (_this3.doesListening) {\n      _this3.getEventTarget().addEventListener('scroll', _this3.handleScroll);\n    }\n    return _this3;\n  }\n  _createClass(ScrollGeomCache, [{\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.doesListening) {\n        this.getEventTarget().removeEventListener('scroll', this.handleScroll);\n      }\n    }\n  }, {\n    key: \"getScrollTop\",\n    value: function getScrollTop() {\n      return this.scrollTop;\n    }\n  }, {\n    key: \"getScrollLeft\",\n    value: function getScrollLeft() {\n      return this.scrollLeft;\n    }\n  }, {\n    key: \"setScrollTop\",\n    value: function setScrollTop(top) {\n      this.scrollController.setScrollTop(top);\n      if (!this.doesListening) {\n        // we are not relying on the element to normalize out-of-bounds scroll values\n        // so we need to sanitize ourselves\n        this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);\n        this.handleScrollChange();\n      }\n    }\n  }, {\n    key: \"setScrollLeft\",\n    value: function setScrollLeft(top) {\n      this.scrollController.setScrollLeft(top);\n      if (!this.doesListening) {\n        // we are not relying on the element to normalize out-of-bounds scroll values\n        // so we need to sanitize ourselves\n        this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);\n        this.handleScrollChange();\n      }\n    }\n  }, {\n    key: \"getClientWidth\",\n    value: function getClientWidth() {\n      return this.clientWidth;\n    }\n  }, {\n    key: \"getClientHeight\",\n    value: function getClientHeight() {\n      return this.clientHeight;\n    }\n  }, {\n    key: \"getScrollWidth\",\n    value: function getScrollWidth() {\n      return this.scrollWidth;\n    }\n  }, {\n    key: \"getScrollHeight\",\n    value: function getScrollHeight() {\n      return this.scrollHeight;\n    }\n  }, {\n    key: \"handleScrollChange\",\n    value: function handleScrollChange() {}\n  }]);\n  return ScrollGeomCache;\n}(ScrollController);\nvar ElementScrollGeomCache = /*#__PURE__*/function (_ScrollGeomCache) {\n  _inherits(ElementScrollGeomCache, _ScrollGeomCache);\n  function ElementScrollGeomCache(el, doesListening) {\n    _classCallCheck(this, ElementScrollGeomCache);\n    return _possibleConstructorReturn(this, _getPrototypeOf(ElementScrollGeomCache).call(this, new ElementScrollController(el), doesListening));\n  }\n  _createClass(ElementScrollGeomCache, [{\n    key: \"getEventTarget\",\n    value: function getEventTarget() {\n      return this.scrollController.el;\n    }\n  }, {\n    key: \"computeClientRect\",\n    value: function computeClientRect() {\n      return computeInnerRect(this.scrollController.el);\n    }\n  }]);\n  return ElementScrollGeomCache;\n}(ScrollGeomCache);\nvar WindowScrollGeomCache = /*#__PURE__*/function (_ScrollGeomCache2) {\n  _inherits(WindowScrollGeomCache, _ScrollGeomCache2);\n  function WindowScrollGeomCache(doesListening) {\n    _classCallCheck(this, WindowScrollGeomCache);\n    return _possibleConstructorReturn(this, _getPrototypeOf(WindowScrollGeomCache).call(this, new WindowScrollController(), doesListening));\n  }\n  _createClass(WindowScrollGeomCache, [{\n    key: \"getEventTarget\",\n    value: function getEventTarget() {\n      return window;\n    }\n  }, {\n    key: \"computeClientRect\",\n    value: function computeClientRect() {\n      return {\n        left: this.scrollLeft,\n        right: this.scrollLeft + this.clientWidth,\n        top: this.scrollTop,\n        bottom: this.scrollTop + this.clientHeight\n      };\n    } // the window is the only scroll object that changes it's rectangle relative\n    // to the document's topleft as it scrolls\n  }, {\n    key: \"handleScrollChange\",\n    value: function handleScrollChange() {\n      this.clientRect = this.computeClientRect();\n    }\n  }]);\n  return WindowScrollGeomCache;\n}(ScrollGeomCache); // If available we are using native \"performance\" API instead of \"Date\"\n// Read more about it on MDN:\n// https://developer.mozilla.org/en-US/docs/Web/API/Performance\nvar getTime = typeof performance === 'function' ? performance.now : Date.now;\n/*\nFor a pointer interaction, automatically scrolls certain scroll containers when the pointer\napproaches the edge.\n\nThe caller must call start + handleMove + stop.\n*/\nvar AutoScroller = /*#__PURE__*/function () {\n  function AutoScroller() {\n    var _this4 = this;\n    _classCallCheck(this, AutoScroller);\n    // options that can be set by caller\n    this.isEnabled = true;\n    this.scrollQuery = [window, '.fc-scroller'];\n    this.edgeThreshold = 50; // pixels\n    this.maxVelocity = 300; // pixels per second\n    // internal state\n    this.pointerScreenX = null;\n    this.pointerScreenY = null;\n    this.isAnimating = false;\n    this.scrollCaches = null;\n    // protect against the initial pointerdown being too close to an edge and starting the scroll\n    this.everMovedUp = false;\n    this.everMovedDown = false;\n    this.everMovedLeft = false;\n    this.everMovedRight = false;\n    this.animate = function () {\n      if (_this4.isAnimating) {\n        // wasn't cancelled between animation calls\n        var edge = _this4.computeBestEdge(_this4.pointerScreenX + window.pageXOffset, _this4.pointerScreenY + window.pageYOffset);\n        if (edge) {\n          var now = getTime();\n          _this4.handleSide(edge, (now - _this4.msSinceRequest) / 1000);\n          _this4.requestAnimation(now);\n        } else {\n          _this4.isAnimating = false; // will stop animation\n        }\n      }\n    };\n  }\n  _createClass(AutoScroller, [{\n    key: \"start\",\n    value: function start(pageX, pageY, scrollStartEl) {\n      if (this.isEnabled) {\n        this.scrollCaches = this.buildCaches(scrollStartEl);\n        this.pointerScreenX = null;\n        this.pointerScreenY = null;\n        this.everMovedUp = false;\n        this.everMovedDown = false;\n        this.everMovedLeft = false;\n        this.everMovedRight = false;\n        this.handleMove(pageX, pageY);\n      }\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(pageX, pageY) {\n      if (this.isEnabled) {\n        var pointerScreenX = pageX - window.pageXOffset;\n        var pointerScreenY = pageY - window.pageYOffset;\n        var yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;\n        var xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;\n        if (yDelta < 0) {\n          this.everMovedUp = true;\n        } else if (yDelta > 0) {\n          this.everMovedDown = true;\n        }\n        if (xDelta < 0) {\n          this.everMovedLeft = true;\n        } else if (xDelta > 0) {\n          this.everMovedRight = true;\n        }\n        this.pointerScreenX = pointerScreenX;\n        this.pointerScreenY = pointerScreenY;\n        if (!this.isAnimating) {\n          this.isAnimating = true;\n          this.requestAnimation(getTime());\n        }\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.isEnabled) {\n        this.isAnimating = false; // will stop animation\n        var _iterator = _createForOfIteratorHelper(this.scrollCaches),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var scrollCache = _step.value;\n            scrollCache.destroy();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        this.scrollCaches = null;\n      }\n    }\n  }, {\n    key: \"requestAnimation\",\n    value: function requestAnimation(now) {\n      this.msSinceRequest = now;\n      requestAnimationFrame(this.animate);\n    }\n  }, {\n    key: \"handleSide\",\n    value: function handleSide(edge, seconds) {\n      var scrollCache = edge.scrollCache;\n      var edgeThreshold = this.edgeThreshold;\n      var invDistance = edgeThreshold - edge.distance;\n      var velocity =\n      // the closer to the edge, the faster we scroll\n      invDistance * invDistance / (edgeThreshold * edgeThreshold) *\n      // quadratic\n      this.maxVelocity * seconds;\n      var sign = 1;\n      switch (edge.name) {\n        case 'left':\n          sign = -1;\n        // falls through\n        case 'right':\n          scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);\n          break;\n        case 'top':\n          sign = -1;\n        // falls through\n        case 'bottom':\n          scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);\n          break;\n      }\n    } // left/top are relative to document topleft\n  }, {\n    key: \"computeBestEdge\",\n    value: function computeBestEdge(left, top) {\n      var edgeThreshold = this.edgeThreshold;\n      var bestSide = null;\n      var scrollCaches = this.scrollCaches || [];\n      var _iterator2 = _createForOfIteratorHelper(scrollCaches),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var scrollCache = _step2.value;\n          var rect = scrollCache.clientRect;\n          var leftDist = left - rect.left;\n          var rightDist = rect.right - left;\n          var topDist = top - rect.top;\n          var bottomDist = rect.bottom - top;\n          // completely within the rect?\n          if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {\n            if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() && (!bestSide || bestSide.distance > topDist)) {\n              bestSide = {\n                scrollCache: scrollCache,\n                name: 'top',\n                distance: topDist\n              };\n            }\n            if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() && (!bestSide || bestSide.distance > bottomDist)) {\n              bestSide = {\n                scrollCache: scrollCache,\n                name: 'bottom',\n                distance: bottomDist\n              };\n            }\n            if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() && (!bestSide || bestSide.distance > leftDist)) {\n              bestSide = {\n                scrollCache: scrollCache,\n                name: 'left',\n                distance: leftDist\n              };\n            }\n            if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() && (!bestSide || bestSide.distance > rightDist)) {\n              bestSide = {\n                scrollCache: scrollCache,\n                name: 'right',\n                distance: rightDist\n              };\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return bestSide;\n    }\n  }, {\n    key: \"buildCaches\",\n    value: function buildCaches(scrollStartEl) {\n      return this.queryScrollEls(scrollStartEl).map(function (el) {\n        if (el === window) {\n          return new WindowScrollGeomCache(false); // false = don't listen to user-generated scrolls\n        }\n\n        return new ElementScrollGeomCache(el, false); // false = don't listen to user-generated scrolls\n      });\n    }\n  }, {\n    key: \"queryScrollEls\",\n    value: function queryScrollEls(scrollStartEl) {\n      var els = [];\n      var _iterator3 = _createForOfIteratorHelper(this.scrollQuery),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var query = _step3.value;\n          if (typeof query === 'object') {\n            els.push(query);\n          } else {\n            els.push.apply(els, _toConsumableArray(Array.prototype.slice.call(scrollStartEl.getRootNode().querySelectorAll(query))));\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return els;\n    }\n  }]);\n  return AutoScroller;\n}();\n/*\nMonitors dragging on an element. Has a number of high-level features:\n- minimum distance required before dragging\n- minimum wait time (\"delay\") before dragging\n- a mirror element that follows the pointer\n*/\nvar FeaturefulElementDragging = /*#__PURE__*/function (_ElementDragging) {\n  _inherits(FeaturefulElementDragging, _ElementDragging);\n  function FeaturefulElementDragging(containerEl, selector) {\n    var _this5;\n    _classCallCheck(this, FeaturefulElementDragging);\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(FeaturefulElementDragging).call(this, containerEl));\n    _this5.containerEl = containerEl;\n    // options that can be directly set by caller\n    // the caller can also set the PointerDragging's options as well\n    _this5.delay = null;\n    _this5.minDistance = 0;\n    _this5.touchScrollAllowed = true; // prevents drag from starting and blocks scrolling during drag\n    _this5.mirrorNeedsRevert = false;\n    _this5.isInteracting = false; // is the user validly moving the pointer? lasts until pointerup\n    _this5.isDragging = false; // is it INTENTFULLY dragging? lasts until after revert animation\n    _this5.isDelayEnded = false;\n    _this5.isDistanceSurpassed = false;\n    _this5.delayTimeoutId = null;\n    _this5.onPointerDown = function (ev) {\n      if (!_this5.isDragging) {\n        // so new drag doesn't happen while revert animation is going\n        _this5.isInteracting = true;\n        _this5.isDelayEnded = false;\n        _this5.isDistanceSurpassed = false;\n        preventSelection(document.body);\n        preventContextMenu(document.body);\n        // prevent links from being visited if there's an eventual drag.\n        // also prevents selection in older browsers (maybe?).\n        // not necessary for touch, besides, browser would complain about passiveness.\n        if (!ev.isTouch) {\n          ev.origEvent.preventDefault();\n        }\n        _this5.emitter.trigger('pointerdown', ev);\n        if (_this5.isInteracting &&\n        // not destroyed via pointerdown handler\n        !_this5.pointer.shouldIgnoreMove) {\n          // actions related to initiating dragstart+dragmove+dragend...\n          _this5.mirror.setIsVisible(false); // reset. caller must set-visible\n          _this5.mirror.start(ev.subjectEl, ev.pageX, ev.pageY); // must happen on first pointer down\n          _this5.startDelay(ev);\n          if (!_this5.minDistance) {\n            _this5.handleDistanceSurpassed(ev);\n          }\n        }\n      }\n    };\n    _this5.onPointerMove = function (ev) {\n      if (_this5.isInteracting) {\n        _this5.emitter.trigger('pointermove', ev);\n        if (!_this5.isDistanceSurpassed) {\n          var minDistance = _this5.minDistance;\n          var distanceSq; // current distance from the origin, squared\n          var deltaX = ev.deltaX,\n            deltaY = ev.deltaY;\n          distanceSq = deltaX * deltaX + deltaY * deltaY;\n          if (distanceSq >= minDistance * minDistance) {\n            // use pythagorean theorem\n            _this5.handleDistanceSurpassed(ev);\n          }\n        }\n        if (_this5.isDragging) {\n          // a real pointer move? (not one simulated by scrolling)\n          if (ev.origEvent.type !== 'scroll') {\n            _this5.mirror.handleMove(ev.pageX, ev.pageY);\n            _this5.autoScroller.handleMove(ev.pageX, ev.pageY);\n          }\n          _this5.emitter.trigger('dragmove', ev);\n        }\n      }\n    };\n    _this5.onPointerUp = function (ev) {\n      if (_this5.isInteracting) {\n        _this5.isInteracting = false;\n        allowSelection(document.body);\n        allowContextMenu(document.body);\n        _this5.emitter.trigger('pointerup', ev); // can potentially set mirrorNeedsRevert\n        if (_this5.isDragging) {\n          _this5.autoScroller.stop();\n          _this5.tryStopDrag(ev); // which will stop the mirror\n        }\n\n        if (_this5.delayTimeoutId) {\n          clearTimeout(_this5.delayTimeoutId);\n          _this5.delayTimeoutId = null;\n        }\n      }\n    };\n    var pointer = _this5.pointer = new PointerDragging(containerEl);\n    pointer.emitter.on('pointerdown', _this5.onPointerDown);\n    pointer.emitter.on('pointermove', _this5.onPointerMove);\n    pointer.emitter.on('pointerup', _this5.onPointerUp);\n    if (selector) {\n      pointer.selector = selector;\n    }\n    _this5.mirror = new ElementMirror();\n    _this5.autoScroller = new AutoScroller();\n    return _this5;\n  }\n  _createClass(FeaturefulElementDragging, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.pointer.destroy();\n      // HACK: simulate a pointer-up to end the current drag\n      // TODO: fire 'dragend' directly and stop interaction. discourage use of pointerup event (b/c might not fire)\n      this.onPointerUp({});\n    }\n  }, {\n    key: \"startDelay\",\n    value: function startDelay(ev) {\n      var _this6 = this;\n      if (typeof this.delay === 'number') {\n        this.delayTimeoutId = setTimeout(function () {\n          _this6.delayTimeoutId = null;\n          _this6.handleDelayEnd(ev);\n        }, this.delay); // not assignable to number!\n      } else {\n        this.handleDelayEnd(ev);\n      }\n    }\n  }, {\n    key: \"handleDelayEnd\",\n    value: function handleDelayEnd(ev) {\n      this.isDelayEnded = true;\n      this.tryStartDrag(ev);\n    }\n  }, {\n    key: \"handleDistanceSurpassed\",\n    value: function handleDistanceSurpassed(ev) {\n      this.isDistanceSurpassed = true;\n      this.tryStartDrag(ev);\n    }\n  }, {\n    key: \"tryStartDrag\",\n    value: function tryStartDrag(ev) {\n      if (this.isDelayEnded && this.isDistanceSurpassed) {\n        if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {\n          this.isDragging = true;\n          this.mirrorNeedsRevert = false;\n          this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);\n          this.emitter.trigger('dragstart', ev);\n          if (this.touchScrollAllowed === false) {\n            this.pointer.cancelTouchScroll();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"tryStopDrag\",\n    value: function tryStopDrag(ev) {\n      // .stop() is ALWAYS asynchronous, which we NEED because we want all pointerup events\n      // that come from the document to fire beforehand. much more convenient this way.\n      this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));\n    }\n  }, {\n    key: \"stopDrag\",\n    value: function stopDrag(ev) {\n      this.isDragging = false;\n      this.emitter.trigger('dragend', ev);\n    } // fill in the implementations...\n  }, {\n    key: \"setIgnoreMove\",\n    value: function setIgnoreMove(bool) {\n      this.pointer.shouldIgnoreMove = bool;\n    }\n  }, {\n    key: \"setMirrorIsVisible\",\n    value: function setMirrorIsVisible(bool) {\n      this.mirror.setIsVisible(bool);\n    }\n  }, {\n    key: \"setMirrorNeedsRevert\",\n    value: function setMirrorNeedsRevert(bool) {\n      this.mirrorNeedsRevert = bool;\n    }\n  }, {\n    key: \"setAutoScrollEnabled\",\n    value: function setAutoScrollEnabled(bool) {\n      this.autoScroller.isEnabled = bool;\n    }\n  }]);\n  return FeaturefulElementDragging;\n}(ElementDragging);\n/*\nWhen this class is instantiated, it records the offset of an element (relative to the document topleft),\nand continues to monitor scrolling, updating the cached coordinates if it needs to.\nDoes not access the DOM after instantiation, so highly performant.\n\nAlso keeps track of all scrolling/overflow:hidden containers that are parents of the given element\nand an determine if a given point is inside the combined clipping rectangle.\n*/\nvar OffsetTracker = /*#__PURE__*/function () {\n  function OffsetTracker(el) {\n    _classCallCheck(this, OffsetTracker);\n    this.origRect = computeRect(el);\n    // will work fine for divs that have overflow:hidden\n    this.scrollCaches = getClippingParents(el).map(function (scrollEl) {\n      return new ElementScrollGeomCache(scrollEl, true);\n    });\n  }\n  _createClass(OffsetTracker, [{\n    key: \"destroy\",\n    value: function destroy() {\n      var _iterator4 = _createForOfIteratorHelper(this.scrollCaches),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var scrollCache = _step4.value;\n          scrollCache.destroy();\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"computeLeft\",\n    value: function computeLeft() {\n      var left = this.origRect.left;\n      var _iterator5 = _createForOfIteratorHelper(this.scrollCaches),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var scrollCache = _step5.value;\n          left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      return left;\n    }\n  }, {\n    key: \"computeTop\",\n    value: function computeTop() {\n      var top = this.origRect.top;\n      var _iterator6 = _createForOfIteratorHelper(this.scrollCaches),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var scrollCache = _step6.value;\n          top += scrollCache.origScrollTop - scrollCache.getScrollTop();\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      return top;\n    }\n  }, {\n    key: \"isWithinClipping\",\n    value: function isWithinClipping(pageX, pageY) {\n      var point = {\n        left: pageX,\n        top: pageY\n      };\n      var _iterator7 = _createForOfIteratorHelper(this.scrollCaches),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var scrollCache = _step7.value;\n          if (!isIgnoredClipping(scrollCache.getEventTarget()) && !pointInsideRect(point, scrollCache.clientRect)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      return true;\n    }\n  }]);\n  return OffsetTracker;\n}(); // certain clipping containers should never constrain interactions, like <html> and <body>\n// https://github.com/fullcalendar/fullcalendar/issues/3615\nfunction isIgnoredClipping(node) {\n  var tagName = node.tagName;\n  return tagName === 'HTML' || tagName === 'BODY';\n}\n\n/*\nTracks movement over multiple droppable areas (aka \"hits\")\nthat exist in one or more DateComponents.\nRelies on an existing draggable.\n\nemits:\n- pointerdown\n- dragstart\n- hitchange - fires initially, even if not over a hit\n- pointerup\n- (hitchange - again, to null, if ended over a hit)\n- dragend\n*/\nvar HitDragging = /*#__PURE__*/function () {\n  function HitDragging(dragging, droppableStore) {\n    var _this7 = this;\n    _classCallCheck(this, HitDragging);\n    // options that can be set by caller\n    this.useSubjectCenter = false;\n    this.requireInitial = true; // if doesn't start out on a hit, won't emit any events\n    this.initialHit = null;\n    this.movingHit = null;\n    this.finalHit = null; // won't ever be populated if shouldIgnoreMove\n    this.handlePointerDown = function (ev) {\n      var dragging = _this7.dragging;\n      _this7.initialHit = null;\n      _this7.movingHit = null;\n      _this7.finalHit = null;\n      _this7.prepareHits();\n      _this7.processFirstCoord(ev);\n      if (_this7.initialHit || !_this7.requireInitial) {\n        dragging.setIgnoreMove(false);\n        // TODO: fire this before computing processFirstCoord, so listeners can cancel. this gets fired by almost every handler :(\n        _this7.emitter.trigger('pointerdown', ev);\n      } else {\n        dragging.setIgnoreMove(true);\n      }\n    };\n    this.handleDragStart = function (ev) {\n      _this7.emitter.trigger('dragstart', ev);\n      _this7.handleMove(ev, true); // force = fire even if initially null\n    };\n\n    this.handleDragMove = function (ev) {\n      _this7.emitter.trigger('dragmove', ev);\n      _this7.handleMove(ev);\n    };\n    this.handlePointerUp = function (ev) {\n      _this7.releaseHits();\n      _this7.emitter.trigger('pointerup', ev);\n    };\n    this.handleDragEnd = function (ev) {\n      if (_this7.movingHit) {\n        _this7.emitter.trigger('hitupdate', null, true, ev);\n      }\n      _this7.finalHit = _this7.movingHit;\n      _this7.movingHit = null;\n      _this7.emitter.trigger('dragend', ev);\n    };\n    this.droppableStore = droppableStore;\n    dragging.emitter.on('pointerdown', this.handlePointerDown);\n    dragging.emitter.on('dragstart', this.handleDragStart);\n    dragging.emitter.on('dragmove', this.handleDragMove);\n    dragging.emitter.on('pointerup', this.handlePointerUp);\n    dragging.emitter.on('dragend', this.handleDragEnd);\n    this.dragging = dragging;\n    this.emitter = new Emitter();\n  }\n  // sets initialHit\n  // sets coordAdjust\n  _createClass(HitDragging, [{\n    key: \"processFirstCoord\",\n    value: function processFirstCoord(ev) {\n      var origPoint = {\n        left: ev.pageX,\n        top: ev.pageY\n      };\n      var adjustedPoint = origPoint;\n      var subjectEl = ev.subjectEl;\n      var subjectRect;\n      if (subjectEl instanceof HTMLElement) {\n        // i.e. not a Document/ShadowRoot\n        subjectRect = computeRect(subjectEl);\n        adjustedPoint = constrainPoint(adjustedPoint, subjectRect);\n      }\n      var initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);\n      if (initialHit) {\n        if (this.useSubjectCenter && subjectRect) {\n          var slicedSubjectRect = intersectRects(subjectRect, initialHit.rect);\n          if (slicedSubjectRect) {\n            adjustedPoint = getRectCenter(slicedSubjectRect);\n          }\n        }\n        this.coordAdjust = diffPoints(adjustedPoint, origPoint);\n      } else {\n        this.coordAdjust = {\n          left: 0,\n          top: 0\n        };\n      }\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(ev, forceHandle) {\n      var hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);\n      if (forceHandle || !isHitsEqual(this.movingHit, hit)) {\n        this.movingHit = hit;\n        this.emitter.trigger('hitupdate', hit, false, ev);\n      }\n    }\n  }, {\n    key: \"prepareHits\",\n    value: function prepareHits() {\n      this.offsetTrackers = mapHash(this.droppableStore, function (interactionSettings) {\n        interactionSettings.component.prepareHits();\n        return new OffsetTracker(interactionSettings.el);\n      });\n    }\n  }, {\n    key: \"releaseHits\",\n    value: function releaseHits() {\n      var offsetTrackers = this.offsetTrackers;\n      for (var id in offsetTrackers) {\n        offsetTrackers[id].destroy();\n      }\n      this.offsetTrackers = {};\n    }\n  }, {\n    key: \"queryHitForOffset\",\n    value: function queryHitForOffset(offsetLeft, offsetTop) {\n      var droppableStore = this.droppableStore,\n        offsetTrackers = this.offsetTrackers;\n      var bestHit = null;\n      for (var id in droppableStore) {\n        var component = droppableStore[id].component;\n        var offsetTracker = offsetTrackers[id];\n        if (offsetTracker &&\n        // wasn't destroyed mid-drag\n        offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {\n          var originLeft = offsetTracker.computeLeft();\n          var originTop = offsetTracker.computeTop();\n          var positionLeft = offsetLeft - originLeft;\n          var positionTop = offsetTop - originTop;\n          var origRect = offsetTracker.origRect;\n          var width = origRect.right - origRect.left;\n          var height = origRect.bottom - origRect.top;\n          if (\n          // must be within the element's bounds\n          positionLeft >= 0 && positionLeft < width && positionTop >= 0 && positionTop < height) {\n            var hit = component.queryHit(positionLeft, positionTop, width, height);\n            if (hit &&\n            // make sure the hit is within activeRange, meaning it's not a dead cell\n            rangeContainsRange(hit.dateProfile.activeRange, hit.dateSpan.range) && (!bestHit || hit.layer > bestHit.layer)) {\n              hit.componentId = id;\n              hit.context = component.context;\n              // TODO: better way to re-orient rectangle\n              hit.rect.left += originLeft;\n              hit.rect.right += originLeft;\n              hit.rect.top += originTop;\n              hit.rect.bottom += originTop;\n              bestHit = hit;\n            }\n          }\n        }\n      }\n      return bestHit;\n    }\n  }]);\n  return HitDragging;\n}();\nfunction isHitsEqual(hit0, hit1) {\n  if (!hit0 && !hit1) {\n    return true;\n  }\n  if (Boolean(hit0) !== Boolean(hit1)) {\n    return false;\n  }\n  return isDateSpansEqual(hit0.dateSpan, hit1.dateSpan);\n}\nfunction buildDatePointApiWithContext(dateSpan, context) {\n  var props = {};\n  var _iterator8 = _createForOfIteratorHelper(context.pluginHooks.datePointTransforms),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var transform = _step8.value;\n      Object.assign(props, transform(dateSpan, context));\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n  Object.assign(props, buildDatePointApi(dateSpan, context.dateEnv));\n  return props;\n}\nfunction buildDatePointApi(span, dateEnv) {\n  return {\n    date: dateEnv.toDate(span.range.start),\n    dateStr: dateEnv.formatIso(span.range.start, {\n      omitTime: span.allDay\n    }),\n    allDay: span.allDay\n  };\n}\n\n/*\nMonitors when the user clicks on a specific date/time of a component.\nA pointerdown+pointerup on the same \"hit\" constitutes a click.\n*/\nvar DateClicking = /*#__PURE__*/function (_Interaction) {\n  _inherits(DateClicking, _Interaction);\n  function DateClicking(settings) {\n    var _this8;\n    _classCallCheck(this, DateClicking);\n    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(DateClicking).call(this, settings));\n    _this8.handlePointerDown = function (pev) {\n      var _assertThisInitialize = _assertThisInitialized(_assertThisInitialized(_this8)),\n        dragging = _assertThisInitialize.dragging;\n      var downEl = pev.origEvent.target;\n      // do this in pointerdown (not dragend) because DOM might be mutated by the time dragend is fired\n      dragging.setIgnoreMove(!_this8.component.isValidDateDownEl(downEl));\n    };\n    // won't even fire if moving was ignored\n    _this8.handleDragEnd = function (ev) {\n      var _assertThisInitialize2 = _assertThisInitialized(_assertThisInitialized(_this8)),\n        component = _assertThisInitialize2.component;\n      var pointer = _this8.dragging.pointer;\n      if (!pointer.wasTouchScroll) {\n        var _this8$hitDragging = _this8.hitDragging,\n          initialHit = _this8$hitDragging.initialHit,\n          finalHit = _this8$hitDragging.finalHit;\n        if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {\n          var context = component.context;\n          var arg = Object.assign(Object.assign({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), {\n            dayEl: initialHit.dayEl,\n            jsEvent: ev.origEvent,\n            view: context.viewApi || context.calendarApi.view\n          });\n          context.emitter.trigger('dateClick', arg);\n        }\n      }\n    };\n    // we DO want to watch pointer moves because otherwise finalHit won't get populated\n    _this8.dragging = new FeaturefulElementDragging(settings.el);\n    _this8.dragging.autoScroller.isEnabled = false;\n    var hitDragging = _this8.hitDragging = new HitDragging(_this8.dragging, interactionSettingsToStore(settings));\n    hitDragging.emitter.on('pointerdown', _this8.handlePointerDown);\n    hitDragging.emitter.on('dragend', _this8.handleDragEnd);\n    return _this8;\n  }\n  _createClass(DateClicking, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.dragging.destroy();\n    }\n  }]);\n  return DateClicking;\n}(Interaction);\n/*\nTracks when the user selects a portion of time of a component,\nconstituted by a drag over date cells, with a possible delay at the beginning of the drag.\n*/\nvar DateSelecting = /*#__PURE__*/function (_Interaction2) {\n  _inherits(DateSelecting, _Interaction2);\n  function DateSelecting(settings) {\n    var _this9;\n    _classCallCheck(this, DateSelecting);\n    _this9 = _possibleConstructorReturn(this, _getPrototypeOf(DateSelecting).call(this, settings));\n    _this9.dragSelection = null;\n    _this9.handlePointerDown = function (ev) {\n      var _assertThisInitialize3 = _assertThisInitialized(_assertThisInitialized(_this9)),\n        component = _assertThisInitialize3.component,\n        dragging = _assertThisInitialize3.dragging;\n      var options = component.context.options;\n      var canSelect = options.selectable && component.isValidDateDownEl(ev.origEvent.target);\n      // don't bother to watch expensive moves if component won't do selection\n      dragging.setIgnoreMove(!canSelect);\n      // if touch, require user to hold down\n      dragging.delay = ev.isTouch ? getComponentTouchDelay$1(component) : null;\n    };\n    _this9.handleDragStart = function (ev) {\n      _this9.component.context.calendarApi.unselect(ev); // unselect previous selections\n    };\n\n    _this9.handleHitUpdate = function (hit, isFinal) {\n      var context = _this9.component.context;\n      var dragSelection = null;\n      var isInvalid = false;\n      if (hit) {\n        var initialHit = _this9.hitDragging.initialHit;\n        var disallowed = hit.componentId === initialHit.componentId && _this9.isHitComboAllowed && !_this9.isHitComboAllowed(initialHit, hit);\n        if (!disallowed) {\n          dragSelection = joinHitsIntoSelection(initialHit, hit, context.pluginHooks.dateSelectionTransformers);\n        }\n        if (!dragSelection || !isDateSelectionValid(dragSelection, hit.dateProfile, context)) {\n          isInvalid = true;\n          dragSelection = null;\n        }\n      }\n      if (dragSelection) {\n        context.dispatch({\n          type: 'SELECT_DATES',\n          selection: dragSelection\n        });\n      } else if (!isFinal) {\n        // only unselect if moved away while dragging\n        context.dispatch({\n          type: 'UNSELECT_DATES'\n        });\n      }\n      if (!isInvalid) {\n        enableCursor();\n      } else {\n        disableCursor();\n      }\n      if (!isFinal) {\n        _this9.dragSelection = dragSelection; // only clear if moved away from all hits while dragging\n      }\n    };\n\n    _this9.handlePointerUp = function (pev) {\n      if (_this9.dragSelection) {\n        // selection is already rendered, so just need to report selection\n        triggerDateSelect(_this9.dragSelection, pev, _this9.component.context);\n        _this9.dragSelection = null;\n      }\n    };\n    var component = settings.component;\n    var options = component.context.options;\n    var dragging = _this9.dragging = new FeaturefulElementDragging(settings.el);\n    dragging.touchScrollAllowed = false;\n    dragging.minDistance = options.selectMinDistance || 0;\n    dragging.autoScroller.isEnabled = options.dragScroll;\n    var hitDragging = _this9.hitDragging = new HitDragging(_this9.dragging, interactionSettingsToStore(settings));\n    hitDragging.emitter.on('pointerdown', _this9.handlePointerDown);\n    hitDragging.emitter.on('dragstart', _this9.handleDragStart);\n    hitDragging.emitter.on('hitupdate', _this9.handleHitUpdate);\n    hitDragging.emitter.on('pointerup', _this9.handlePointerUp);\n    return _this9;\n  }\n  _createClass(DateSelecting, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.dragging.destroy();\n    }\n  }]);\n  return DateSelecting;\n}(Interaction);\nfunction getComponentTouchDelay$1(component) {\n  var options = component.context.options;\n  var delay = options.selectLongPressDelay;\n  if (delay == null) {\n    delay = options.longPressDelay;\n  }\n  return delay;\n}\nfunction joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {\n  var dateSpan0 = hit0.dateSpan;\n  var dateSpan1 = hit1.dateSpan;\n  var ms = [dateSpan0.range.start, dateSpan0.range.end, dateSpan1.range.start, dateSpan1.range.end];\n  ms.sort(compareNumbers);\n  var props = {};\n  var _iterator9 = _createForOfIteratorHelper(dateSelectionTransformers),\n    _step9;\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var transformer = _step9.value;\n      var res = transformer(hit0, hit1);\n      if (res === false) {\n        return null;\n      }\n      if (res) {\n        Object.assign(props, res);\n      }\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n  props.range = {\n    start: ms[0],\n    end: ms[3]\n  };\n  props.allDay = dateSpan0.allDay;\n  return props;\n}\nvar EventDragging = /*#__PURE__*/function (_Interaction3) {\n  _inherits(EventDragging, _Interaction3);\n  function EventDragging(settings) {\n    var _this10;\n    _classCallCheck(this, EventDragging);\n    _this10 = _possibleConstructorReturn(this, _getPrototypeOf(EventDragging).call(this, settings));\n    // internal state\n    _this10.subjectEl = null;\n    _this10.subjectSeg = null; // the seg being selected/dragged\n    _this10.isDragging = false;\n    _this10.eventRange = null;\n    _this10.relevantEvents = null; // the events being dragged\n    _this10.receivingContext = null;\n    _this10.validMutation = null;\n    _this10.mutatedRelevantEvents = null;\n    _this10.handlePointerDown = function (ev) {\n      var origTarget = ev.origEvent.target;\n      var _assertThisInitialize4 = _assertThisInitialized(_assertThisInitialized(_this10)),\n        component = _assertThisInitialize4.component,\n        dragging = _assertThisInitialize4.dragging;\n      var mirror = dragging.mirror;\n      var options = component.context.options;\n      var initialContext = component.context;\n      _this10.subjectEl = ev.subjectEl;\n      var subjectSeg = _this10.subjectSeg = getElSeg(ev.subjectEl);\n      var eventRange = _this10.eventRange = subjectSeg.eventRange;\n      var eventInstanceId = eventRange.instance.instanceId;\n      _this10.relevantEvents = getRelevantEvents(initialContext.getCurrentData().eventStore, eventInstanceId);\n      dragging.minDistance = ev.isTouch ? 0 : options.eventDragMinDistance;\n      dragging.delay =\n      // only do a touch delay if touch and this event hasn't been selected yet\n      ev.isTouch && eventInstanceId !== component.props.eventSelection ? getComponentTouchDelay(component) : null;\n      if (options.fixedMirrorParent) {\n        mirror.parentNode = options.fixedMirrorParent;\n      } else {\n        mirror.parentNode = elementClosest(origTarget, '.fc');\n      }\n      mirror.revertDuration = options.dragRevertDuration;\n      var isValid = component.isValidSegDownEl(origTarget) && !elementClosest(origTarget, '.fc-event-resizer'); // NOT on a resizer\n      dragging.setIgnoreMove(!isValid);\n      // disable dragging for elements that are resizable (ie, selectable)\n      // but are not draggable\n      _this10.isDragging = isValid && ev.subjectEl.classList.contains('fc-event-draggable');\n    };\n    _this10.handleDragStart = function (ev) {\n      var initialContext = _this10.component.context;\n      var eventRange = _this10.eventRange;\n      var eventInstanceId = eventRange.instance.instanceId;\n      if (ev.isTouch) {\n        // need to select a different event?\n        if (eventInstanceId !== _this10.component.props.eventSelection) {\n          initialContext.dispatch({\n            type: 'SELECT_EVENT',\n            eventInstanceId: eventInstanceId\n          });\n        }\n      } else {\n        // if now using mouse, but was previous touch interaction, clear selected event\n        initialContext.dispatch({\n          type: 'UNSELECT_EVENT'\n        });\n      }\n      if (_this10.isDragging) {\n        initialContext.calendarApi.unselect(ev); // unselect *date* selection\n        initialContext.emitter.trigger('eventDragStart', {\n          el: _this10.subjectEl,\n          event: new EventImpl(initialContext, eventRange.def, eventRange.instance),\n          jsEvent: ev.origEvent,\n          view: initialContext.viewApi\n        });\n      }\n    };\n    _this10.handleHitUpdate = function (hit, isFinal) {\n      if (!_this10.isDragging) {\n        return;\n      }\n      var relevantEvents = _this10.relevantEvents;\n      var initialHit = _this10.hitDragging.initialHit;\n      var initialContext = _this10.component.context;\n      // states based on new hit\n      var receivingContext = null;\n      var mutation = null;\n      var mutatedRelevantEvents = null;\n      var isInvalid = false;\n      var interaction = {\n        affectedEvents: relevantEvents,\n        mutatedEvents: createEmptyEventStore(),\n        isEvent: true\n      };\n      if (hit) {\n        receivingContext = hit.context;\n        var receivingOptions = receivingContext.options;\n        if (initialContext === receivingContext || receivingOptions.editable && receivingOptions.droppable) {\n          mutation = computeEventMutation(initialHit, hit, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);\n          if (mutation) {\n            mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);\n            interaction.mutatedEvents = mutatedRelevantEvents;\n            if (!isInteractionValid(interaction, hit.dateProfile, receivingContext)) {\n              isInvalid = true;\n              mutation = null;\n              mutatedRelevantEvents = null;\n              interaction.mutatedEvents = createEmptyEventStore();\n            }\n          }\n        } else {\n          receivingContext = null;\n        }\n      }\n      _this10.displayDrag(receivingContext, interaction);\n      if (!isInvalid) {\n        enableCursor();\n      } else {\n        disableCursor();\n      }\n      if (!isFinal) {\n        if (initialContext === receivingContext &&\n        // TODO: write test for this\n        isHitsEqual(initialHit, hit)) {\n          mutation = null;\n        }\n        _this10.dragging.setMirrorNeedsRevert(!mutation);\n        // render the mirror if no already-rendered mirror\n        // TODO: wish we could somehow wait for dispatch to guarantee render\n        _this10.dragging.setMirrorIsVisible(!hit || !_this10.subjectEl.getRootNode().querySelector('.fc-event-mirror'));\n        // assign states based on new hit\n        _this10.receivingContext = receivingContext;\n        _this10.validMutation = mutation;\n        _this10.mutatedRelevantEvents = mutatedRelevantEvents;\n      }\n    };\n    _this10.handlePointerUp = function () {\n      if (!_this10.isDragging) {\n        _this10.cleanup(); // because handleDragEnd won't fire\n      }\n    };\n\n    _this10.handleDragEnd = function (ev) {\n      if (_this10.isDragging) {\n        var initialContext = _this10.component.context;\n        var initialView = initialContext.viewApi;\n        var _assertThisInitialize5 = _assertThisInitialized(_assertThisInitialized(_this10)),\n          receivingContext = _assertThisInitialize5.receivingContext,\n          validMutation = _assertThisInitialize5.validMutation;\n        var eventDef = _this10.eventRange.def;\n        var eventInstance = _this10.eventRange.instance;\n        var eventApi = new EventImpl(initialContext, eventDef, eventInstance);\n        var relevantEvents = _this10.relevantEvents;\n        var mutatedRelevantEvents = _this10.mutatedRelevantEvents;\n        var finalHit = _this10.hitDragging.finalHit;\n        _this10.clearDrag(); // must happen after revert animation\n        initialContext.emitter.trigger('eventDragStop', {\n          el: _this10.subjectEl,\n          event: eventApi,\n          jsEvent: ev.origEvent,\n          view: initialView\n        });\n        if (validMutation) {\n          // dropped within same calendar\n          if (receivingContext === initialContext) {\n            var updatedEventApi = new EventImpl(initialContext, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);\n            initialContext.dispatch({\n              type: 'MERGE_EVENTS',\n              eventStore: mutatedRelevantEvents\n            });\n            var eventChangeArg = {\n              oldEvent: eventApi,\n              event: updatedEventApi,\n              relatedEvents: buildEventApis(mutatedRelevantEvents, initialContext, eventInstance),\n              revert: function revert() {\n                initialContext.dispatch({\n                  type: 'MERGE_EVENTS',\n                  eventStore: relevantEvents // the pre-change data\n                });\n              }\n            };\n\n            var transformed = {};\n            var _iterator10 = _createForOfIteratorHelper(initialContext.getCurrentData().pluginHooks.eventDropTransformers),\n              _step10;\n            try {\n              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                var transformer = _step10.value;\n                Object.assign(transformed, transformer(validMutation, initialContext));\n              }\n            } catch (err) {\n              _iterator10.e(err);\n            } finally {\n              _iterator10.f();\n            }\n            initialContext.emitter.trigger('eventDrop', Object.assign(Object.assign(Object.assign({}, eventChangeArg), transformed), {\n              el: ev.subjectEl,\n              delta: validMutation.datesDelta,\n              jsEvent: ev.origEvent,\n              view: initialView\n            }));\n            initialContext.emitter.trigger('eventChange', eventChangeArg);\n            // dropped in different calendar\n          } else if (receivingContext) {\n            var eventRemoveArg = {\n              event: eventApi,\n              relatedEvents: buildEventApis(relevantEvents, initialContext, eventInstance),\n              revert: function revert() {\n                initialContext.dispatch({\n                  type: 'MERGE_EVENTS',\n                  eventStore: relevantEvents\n                });\n              }\n            };\n            initialContext.emitter.trigger('eventLeave', Object.assign(Object.assign({}, eventRemoveArg), {\n              draggedEl: ev.subjectEl,\n              view: initialView\n            }));\n            initialContext.dispatch({\n              type: 'REMOVE_EVENTS',\n              eventStore: relevantEvents\n            });\n            initialContext.emitter.trigger('eventRemove', eventRemoveArg);\n            var addedEventDef = mutatedRelevantEvents.defs[eventDef.defId];\n            var addedEventInstance = mutatedRelevantEvents.instances[eventInstance.instanceId];\n            var addedEventApi = new EventImpl(receivingContext, addedEventDef, addedEventInstance);\n            receivingContext.dispatch({\n              type: 'MERGE_EVENTS',\n              eventStore: mutatedRelevantEvents\n            });\n            var eventAddArg = {\n              event: addedEventApi,\n              relatedEvents: buildEventApis(mutatedRelevantEvents, receivingContext, addedEventInstance),\n              revert: function revert() {\n                receivingContext.dispatch({\n                  type: 'REMOVE_EVENTS',\n                  eventStore: mutatedRelevantEvents\n                });\n              }\n            };\n            receivingContext.emitter.trigger('eventAdd', eventAddArg);\n            if (ev.isTouch) {\n              receivingContext.dispatch({\n                type: 'SELECT_EVENT',\n                eventInstanceId: eventInstance.instanceId\n              });\n            }\n            receivingContext.emitter.trigger('drop', Object.assign(Object.assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), {\n              draggedEl: ev.subjectEl,\n              jsEvent: ev.origEvent,\n              view: finalHit.context.viewApi\n            }));\n            receivingContext.emitter.trigger('eventReceive', Object.assign(Object.assign({}, eventAddArg), {\n              draggedEl: ev.subjectEl,\n              view: finalHit.context.viewApi\n            }));\n          }\n        } else {\n          initialContext.emitter.trigger('_noEventDrop');\n        }\n      }\n      _this10.cleanup();\n    };\n    var _assertThisInitialize6 = _assertThisInitialized(_assertThisInitialized(_this10)),\n      component = _assertThisInitialize6.component;\n    var options = component.context.options;\n    var dragging = _this10.dragging = new FeaturefulElementDragging(settings.el);\n    dragging.pointer.selector = EventDragging.SELECTOR;\n    dragging.touchScrollAllowed = false;\n    dragging.autoScroller.isEnabled = options.dragScroll;\n    var hitDragging = _this10.hitDragging = new HitDragging(_this10.dragging, interactionSettingsStore);\n    hitDragging.useSubjectCenter = settings.useEventCenter;\n    hitDragging.emitter.on('pointerdown', _this10.handlePointerDown);\n    hitDragging.emitter.on('dragstart', _this10.handleDragStart);\n    hitDragging.emitter.on('hitupdate', _this10.handleHitUpdate);\n    hitDragging.emitter.on('pointerup', _this10.handlePointerUp);\n    hitDragging.emitter.on('dragend', _this10.handleDragEnd);\n    return _this10;\n  }\n  _createClass(EventDragging, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.dragging.destroy();\n    } // render a drag state on the next receivingCalendar\n  }, {\n    key: \"displayDrag\",\n    value: function displayDrag(nextContext, state) {\n      var initialContext = this.component.context;\n      var prevContext = this.receivingContext;\n      // does the previous calendar need to be cleared?\n      if (prevContext && prevContext !== nextContext) {\n        // does the initial calendar need to be cleared?\n        // if so, don't clear all the way. we still need to to hide the affectedEvents\n        if (prevContext === initialContext) {\n          prevContext.dispatch({\n            type: 'SET_EVENT_DRAG',\n            state: {\n              affectedEvents: state.affectedEvents,\n              mutatedEvents: createEmptyEventStore(),\n              isEvent: true\n            }\n          });\n          // completely clear the old calendar if it wasn't the initial\n        } else {\n          prevContext.dispatch({\n            type: 'UNSET_EVENT_DRAG'\n          });\n        }\n      }\n      if (nextContext) {\n        nextContext.dispatch({\n          type: 'SET_EVENT_DRAG',\n          state: state\n        });\n      }\n    }\n  }, {\n    key: \"clearDrag\",\n    value: function clearDrag() {\n      var initialCalendar = this.component.context;\n      var receivingContext = this.receivingContext;\n      if (receivingContext) {\n        receivingContext.dispatch({\n          type: 'UNSET_EVENT_DRAG'\n        });\n      }\n      // the initial calendar might have an dummy drag state from displayDrag\n      if (initialCalendar !== receivingContext) {\n        initialCalendar.dispatch({\n          type: 'UNSET_EVENT_DRAG'\n        });\n      }\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      this.subjectSeg = null;\n      this.isDragging = false;\n      this.eventRange = null;\n      this.relevantEvents = null;\n      this.receivingContext = null;\n      this.validMutation = null;\n      this.mutatedRelevantEvents = null;\n    }\n  }]);\n  return EventDragging;\n}(Interaction); // TODO: test this in IE11\n// QUESTION: why do we need it on the resizable???\nEventDragging.SELECTOR = '.fc-event-draggable, .fc-event-resizable';\nfunction computeEventMutation(hit0, hit1, massagers) {\n  var dateSpan0 = hit0.dateSpan;\n  var dateSpan1 = hit1.dateSpan;\n  var date0 = dateSpan0.range.start;\n  var date1 = dateSpan1.range.start;\n  var standardProps = {};\n  if (dateSpan0.allDay !== dateSpan1.allDay) {\n    standardProps.allDay = dateSpan1.allDay;\n    standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;\n    if (dateSpan1.allDay) {\n      // means date1 is already start-of-day,\n      // but date0 needs to be converted\n      date0 = startOfDay(date0);\n    }\n  }\n  var delta = diffDates(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ? hit0.largeUnit : null);\n  if (delta.milliseconds) {\n    // has hours/minutes/seconds\n    standardProps.allDay = false;\n  }\n  var mutation = {\n    datesDelta: delta,\n    standardProps: standardProps\n  };\n  var _iterator11 = _createForOfIteratorHelper(massagers),\n    _step11;\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var massager = _step11.value;\n      massager(mutation, hit0, hit1);\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n  return mutation;\n}\nfunction getComponentTouchDelay(component) {\n  var options = component.context.options;\n  var delay = options.eventLongPressDelay;\n  if (delay == null) {\n    delay = options.longPressDelay;\n  }\n  return delay;\n}\nvar EventResizing = /*#__PURE__*/function (_Interaction4) {\n  _inherits(EventResizing, _Interaction4);\n  function EventResizing(settings) {\n    var _this11;\n    _classCallCheck(this, EventResizing);\n    _this11 = _possibleConstructorReturn(this, _getPrototypeOf(EventResizing).call(this, settings));\n    // internal state\n    _this11.draggingSegEl = null;\n    _this11.draggingSeg = null; // TODO: rename to resizingSeg? subjectSeg?\n    _this11.eventRange = null;\n    _this11.relevantEvents = null;\n    _this11.validMutation = null;\n    _this11.mutatedRelevantEvents = null;\n    _this11.handlePointerDown = function (ev) {\n      var _assertThisInitialize7 = _assertThisInitialized(_assertThisInitialized(_this11)),\n        component = _assertThisInitialize7.component;\n      var segEl = _this11.querySegEl(ev);\n      var seg = getElSeg(segEl);\n      var eventRange = _this11.eventRange = seg.eventRange;\n      _this11.dragging.minDistance = component.context.options.eventDragMinDistance;\n      // if touch, need to be working with a selected event\n      _this11.dragging.setIgnoreMove(!_this11.component.isValidSegDownEl(ev.origEvent.target) || ev.isTouch && _this11.component.props.eventSelection !== eventRange.instance.instanceId);\n    };\n    _this11.handleDragStart = function (ev) {\n      var context = _this11.component.context;\n      var eventRange = _this11.eventRange;\n      _this11.relevantEvents = getRelevantEvents(context.getCurrentData().eventStore, _this11.eventRange.instance.instanceId);\n      var segEl = _this11.querySegEl(ev);\n      _this11.draggingSegEl = segEl;\n      _this11.draggingSeg = getElSeg(segEl);\n      context.calendarApi.unselect();\n      context.emitter.trigger('eventResizeStart', {\n        el: segEl,\n        event: new EventImpl(context, eventRange.def, eventRange.instance),\n        jsEvent: ev.origEvent,\n        view: context.viewApi\n      });\n    };\n    _this11.handleHitUpdate = function (hit, isFinal, ev) {\n      var context = _this11.component.context;\n      var relevantEvents = _this11.relevantEvents;\n      var initialHit = _this11.hitDragging.initialHit;\n      var eventInstance = _this11.eventRange.instance;\n      var mutation = null;\n      var mutatedRelevantEvents = null;\n      var isInvalid = false;\n      var interaction = {\n        affectedEvents: relevantEvents,\n        mutatedEvents: createEmptyEventStore(),\n        isEvent: true\n      };\n      if (hit) {\n        var disallowed = hit.componentId === initialHit.componentId && _this11.isHitComboAllowed && !_this11.isHitComboAllowed(initialHit, hit);\n        if (!disallowed) {\n          mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains('fc-event-resizer-start'), eventInstance.range);\n        }\n      }\n      if (mutation) {\n        mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);\n        interaction.mutatedEvents = mutatedRelevantEvents;\n        if (!isInteractionValid(interaction, hit.dateProfile, context)) {\n          isInvalid = true;\n          mutation = null;\n          mutatedRelevantEvents = null;\n          interaction.mutatedEvents = null;\n        }\n      }\n      if (mutatedRelevantEvents) {\n        context.dispatch({\n          type: 'SET_EVENT_RESIZE',\n          state: interaction\n        });\n      } else {\n        context.dispatch({\n          type: 'UNSET_EVENT_RESIZE'\n        });\n      }\n      if (!isInvalid) {\n        enableCursor();\n      } else {\n        disableCursor();\n      }\n      if (!isFinal) {\n        if (mutation && isHitsEqual(initialHit, hit)) {\n          mutation = null;\n        }\n        _this11.validMutation = mutation;\n        _this11.mutatedRelevantEvents = mutatedRelevantEvents;\n      }\n    };\n    _this11.handleDragEnd = function (ev) {\n      var context = _this11.component.context;\n      var eventDef = _this11.eventRange.def;\n      var eventInstance = _this11.eventRange.instance;\n      var eventApi = new EventImpl(context, eventDef, eventInstance);\n      var relevantEvents = _this11.relevantEvents;\n      var mutatedRelevantEvents = _this11.mutatedRelevantEvents;\n      context.emitter.trigger('eventResizeStop', {\n        el: _this11.draggingSegEl,\n        event: eventApi,\n        jsEvent: ev.origEvent,\n        view: context.viewApi\n      });\n      if (_this11.validMutation) {\n        var updatedEventApi = new EventImpl(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);\n        context.dispatch({\n          type: 'MERGE_EVENTS',\n          eventStore: mutatedRelevantEvents\n        });\n        var eventChangeArg = {\n          oldEvent: eventApi,\n          event: updatedEventApi,\n          relatedEvents: buildEventApis(mutatedRelevantEvents, context, eventInstance),\n          revert: function revert() {\n            context.dispatch({\n              type: 'MERGE_EVENTS',\n              eventStore: relevantEvents // the pre-change events\n            });\n          }\n        };\n\n        context.emitter.trigger('eventResize', Object.assign(Object.assign({}, eventChangeArg), {\n          el: _this11.draggingSegEl,\n          startDelta: _this11.validMutation.startDelta || createDuration(0),\n          endDelta: _this11.validMutation.endDelta || createDuration(0),\n          jsEvent: ev.origEvent,\n          view: context.viewApi\n        }));\n        context.emitter.trigger('eventChange', eventChangeArg);\n      } else {\n        context.emitter.trigger('_noEventResize');\n      }\n      // reset all internal state\n      _this11.draggingSeg = null;\n      _this11.relevantEvents = null;\n      _this11.validMutation = null;\n      // okay to keep eventInstance around. useful to set it in handlePointerDown\n    };\n    var component = settings.component;\n    var dragging = _this11.dragging = new FeaturefulElementDragging(settings.el);\n    dragging.pointer.selector = '.fc-event-resizer';\n    dragging.touchScrollAllowed = false;\n    dragging.autoScroller.isEnabled = component.context.options.dragScroll;\n    var hitDragging = _this11.hitDragging = new HitDragging(_this11.dragging, interactionSettingsToStore(settings));\n    hitDragging.emitter.on('pointerdown', _this11.handlePointerDown);\n    hitDragging.emitter.on('dragstart', _this11.handleDragStart);\n    hitDragging.emitter.on('hitupdate', _this11.handleHitUpdate);\n    hitDragging.emitter.on('dragend', _this11.handleDragEnd);\n    return _this11;\n  }\n  _createClass(EventResizing, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.dragging.destroy();\n    }\n  }, {\n    key: \"querySegEl\",\n    value: function querySegEl(ev) {\n      return elementClosest(ev.subjectEl, '.fc-event');\n    }\n  }]);\n  return EventResizing;\n}(Interaction);\nfunction computeMutation(hit0, hit1, isFromStart, instanceRange) {\n  var dateEnv = hit0.context.dateEnv;\n  var date0 = hit0.dateSpan.range.start;\n  var date1 = hit1.dateSpan.range.start;\n  var delta = diffDates(date0, date1, dateEnv, hit0.largeUnit);\n  if (isFromStart) {\n    if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {\n      return {\n        startDelta: delta\n      };\n    }\n  } else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {\n    return {\n      endDelta: delta\n    };\n  }\n  return null;\n}\nvar UnselectAuto = /*#__PURE__*/function () {\n  function UnselectAuto(context) {\n    var _this12 = this;\n    _classCallCheck(this, UnselectAuto);\n    this.context = context;\n    this.isRecentPointerDateSelect = false; // wish we could use a selector to detect date selection, but uses hit system\n    this.matchesCancel = false;\n    this.matchesEvent = false;\n    this.onSelect = function (selectInfo) {\n      if (selectInfo.jsEvent) {\n        _this12.isRecentPointerDateSelect = true;\n      }\n    };\n    this.onDocumentPointerDown = function (pev) {\n      var unselectCancel = _this12.context.options.unselectCancel;\n      var downEl = getEventTargetViaRoot(pev.origEvent);\n      _this12.matchesCancel = !!elementClosest(downEl, unselectCancel);\n      _this12.matchesEvent = !!elementClosest(downEl, EventDragging.SELECTOR); // interaction started on an event?\n    };\n\n    this.onDocumentPointerUp = function (pev) {\n      var context = _this12.context;\n      var documentPointer = _this12.documentPointer;\n      var calendarState = context.getCurrentData();\n      // touch-scrolling should never unfocus any type of selection\n      if (!documentPointer.wasTouchScroll) {\n        if (calendarState.dateSelection &&\n        // an existing date selection?\n        !_this12.isRecentPointerDateSelect // a new pointer-initiated date selection since last onDocumentPointerUp?\n        ) {\n          var unselectAuto = context.options.unselectAuto;\n          if (unselectAuto && (!unselectAuto || !_this12.matchesCancel)) {\n            context.calendarApi.unselect(pev);\n          }\n        }\n        if (calendarState.eventSelection &&\n        // an existing event selected?\n        !_this12.matchesEvent // interaction DIDN'T start on an event\n        ) {\n          context.dispatch({\n            type: 'UNSELECT_EVENT'\n          });\n        }\n      }\n      _this12.isRecentPointerDateSelect = false;\n    };\n    var documentPointer = this.documentPointer = new PointerDragging(document);\n    documentPointer.shouldIgnoreMove = true;\n    documentPointer.shouldWatchScroll = false;\n    documentPointer.emitter.on('pointerdown', this.onDocumentPointerDown);\n    documentPointer.emitter.on('pointerup', this.onDocumentPointerUp);\n    /*\n    TODO: better way to know about whether there was a selection with the pointer\n    */\n    context.emitter.on('select', this.onSelect);\n  }\n  _createClass(UnselectAuto, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.context.emitter.off('select', this.onSelect);\n      this.documentPointer.destroy();\n    }\n  }]);\n  return UnselectAuto;\n}();\nvar OPTION_REFINERS = {\n  fixedMirrorParent: identity\n};\nvar LISTENER_REFINERS = {\n  dateClick: identity,\n  eventDragStart: identity,\n  eventDragStop: identity,\n  eventDrop: identity,\n  eventResizeStart: identity,\n  eventResizeStop: identity,\n  eventResize: identity,\n  drop: identity,\n  eventReceive: identity,\n  eventLeave: identity\n};\n\n/*\nGiven an already instantiated draggable object for one-or-more elements,\nInterprets any dragging as an attempt to drag an events that lives outside\nof a calendar onto a calendar.\n*/\nvar ExternalElementDragging = /*#__PURE__*/function () {\n  function ExternalElementDragging(dragging, suppliedDragMeta) {\n    var _this13 = this;\n    _classCallCheck(this, ExternalElementDragging);\n    this.receivingContext = null;\n    this.droppableEvent = null; // will exist for all drags, even if create:false\n    this.suppliedDragMeta = null;\n    this.dragMeta = null;\n    this.handleDragStart = function (ev) {\n      _this13.dragMeta = _this13.buildDragMeta(ev.subjectEl);\n    };\n    this.handleHitUpdate = function (hit, isFinal, ev) {\n      var dragging = _this13.hitDragging.dragging;\n      var receivingContext = null;\n      var droppableEvent = null;\n      var isInvalid = false;\n      var interaction = {\n        affectedEvents: createEmptyEventStore(),\n        mutatedEvents: createEmptyEventStore(),\n        isEvent: _this13.dragMeta.create\n      };\n      if (hit) {\n        receivingContext = hit.context;\n        if (_this13.canDropElOnCalendar(ev.subjectEl, receivingContext)) {\n          droppableEvent = computeEventForDateSpan(hit.dateSpan, _this13.dragMeta, receivingContext);\n          interaction.mutatedEvents = eventTupleToStore(droppableEvent);\n          isInvalid = !isInteractionValid(interaction, hit.dateProfile, receivingContext);\n          if (isInvalid) {\n            interaction.mutatedEvents = createEmptyEventStore();\n            droppableEvent = null;\n          }\n        }\n      }\n      _this13.displayDrag(receivingContext, interaction);\n      // show mirror if no already-rendered mirror element OR if we are shutting down the mirror (?)\n      // TODO: wish we could somehow wait for dispatch to guarantee render\n      dragging.setMirrorIsVisible(isFinal || !droppableEvent || !document.querySelector('.fc-event-mirror'));\n      if (!isInvalid) {\n        enableCursor();\n      } else {\n        disableCursor();\n      }\n      if (!isFinal) {\n        dragging.setMirrorNeedsRevert(!droppableEvent);\n        _this13.receivingContext = receivingContext;\n        _this13.droppableEvent = droppableEvent;\n      }\n    };\n    this.handleDragEnd = function (pev) {\n      var receivingContext = _this13.receivingContext,\n        droppableEvent = _this13.droppableEvent;\n      _this13.clearDrag();\n      if (receivingContext && droppableEvent) {\n        var finalHit = _this13.hitDragging.finalHit;\n        var finalView = finalHit.context.viewApi;\n        var dragMeta = _this13.dragMeta;\n        receivingContext.emitter.trigger('drop', Object.assign(Object.assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), {\n          draggedEl: pev.subjectEl,\n          jsEvent: pev.origEvent,\n          view: finalView\n        }));\n        if (dragMeta.create) {\n          var addingEvents = eventTupleToStore(droppableEvent);\n          receivingContext.dispatch({\n            type: 'MERGE_EVENTS',\n            eventStore: addingEvents\n          });\n          if (pev.isTouch) {\n            receivingContext.dispatch({\n              type: 'SELECT_EVENT',\n              eventInstanceId: droppableEvent.instance.instanceId\n            });\n          }\n          // signal that an external event landed\n          receivingContext.emitter.trigger('eventReceive', {\n            event: new EventImpl(receivingContext, droppableEvent.def, droppableEvent.instance),\n            relatedEvents: [],\n            revert: function revert() {\n              receivingContext.dispatch({\n                type: 'REMOVE_EVENTS',\n                eventStore: addingEvents\n              });\n            },\n            draggedEl: pev.subjectEl,\n            view: finalView\n          });\n        }\n      }\n      _this13.receivingContext = null;\n      _this13.droppableEvent = null;\n    };\n    var hitDragging = this.hitDragging = new HitDragging(dragging, interactionSettingsStore);\n    hitDragging.requireInitial = false; // will start outside of a component\n    hitDragging.emitter.on('dragstart', this.handleDragStart);\n    hitDragging.emitter.on('hitupdate', this.handleHitUpdate);\n    hitDragging.emitter.on('dragend', this.handleDragEnd);\n    this.suppliedDragMeta = suppliedDragMeta;\n  }\n  _createClass(ExternalElementDragging, [{\n    key: \"buildDragMeta\",\n    value: function buildDragMeta(subjectEl) {\n      if (typeof this.suppliedDragMeta === 'object') {\n        return parseDragMeta(this.suppliedDragMeta);\n      }\n      if (typeof this.suppliedDragMeta === 'function') {\n        return parseDragMeta(this.suppliedDragMeta(subjectEl));\n      }\n      return getDragMetaFromEl(subjectEl);\n    }\n  }, {\n    key: \"displayDrag\",\n    value: function displayDrag(nextContext, state) {\n      var prevContext = this.receivingContext;\n      if (prevContext && prevContext !== nextContext) {\n        prevContext.dispatch({\n          type: 'UNSET_EVENT_DRAG'\n        });\n      }\n      if (nextContext) {\n        nextContext.dispatch({\n          type: 'SET_EVENT_DRAG',\n          state: state\n        });\n      }\n    }\n  }, {\n    key: \"clearDrag\",\n    value: function clearDrag() {\n      if (this.receivingContext) {\n        this.receivingContext.dispatch({\n          type: 'UNSET_EVENT_DRAG'\n        });\n      }\n    }\n  }, {\n    key: \"canDropElOnCalendar\",\n    value: function canDropElOnCalendar(el, receivingContext) {\n      var dropAccept = receivingContext.options.dropAccept;\n      if (typeof dropAccept === 'function') {\n        return dropAccept.call(receivingContext.calendarApi, el);\n      }\n      if (typeof dropAccept === 'string' && dropAccept) {\n        return Boolean(elementMatches(el, dropAccept));\n      }\n      return true;\n    }\n  }]);\n  return ExternalElementDragging;\n}(); // Utils for computing event store from the DragMeta\n// ----------------------------------------------------------------------------------------------------\nfunction computeEventForDateSpan(dateSpan, dragMeta, context) {\n  var defProps = Object.assign({}, dragMeta.leftoverProps);\n  var _iterator12 = _createForOfIteratorHelper(context.pluginHooks.externalDefTransforms),\n    _step12;\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var transform = _step12.value;\n      Object.assign(defProps, transform(dateSpan, dragMeta));\n    }\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n  var _refineEventDef = refineEventDef(defProps, context),\n    refined = _refineEventDef.refined,\n    extra = _refineEventDef.extra;\n  var def = parseEventDef(refined, extra, dragMeta.sourceId, dateSpan.allDay, context.options.forceEventDuration || Boolean(dragMeta.duration),\n  // hasEnd\n  context);\n  var start = dateSpan.range.start;\n  // only rely on time info if drop zone is all-day,\n  // otherwise, we already know the time\n  if (dateSpan.allDay && dragMeta.startTime) {\n    start = context.dateEnv.add(start, dragMeta.startTime);\n  }\n  var end = dragMeta.duration ? context.dateEnv.add(start, dragMeta.duration) : getDefaultEventEnd(dateSpan.allDay, start, context);\n  var instance = createEventInstance(def.defId, {\n    start: start,\n    end: end\n  });\n  return {\n    def: def,\n    instance: instance\n  };\n}\n// Utils for extracting data from element\n// ----------------------------------------------------------------------------------------------------\nfunction getDragMetaFromEl(el) {\n  var str = getEmbeddedElData(el, 'event');\n  var obj = str ? JSON.parse(str) : {\n    create: false\n  }; // if no embedded data, assume no event creation\n  return parseDragMeta(obj);\n}\nconfig.dataAttrPrefix = '';\nfunction getEmbeddedElData(el, name) {\n  var prefix = config.dataAttrPrefix;\n  var prefixedName = (prefix ? prefix + '-' : '') + name;\n  return el.getAttribute('data-' + prefixedName) || '';\n}\n\n/*\nMakes an element (that is *external* to any calendar) draggable.\nCan pass in data that determines how an event will be created when dropped onto a calendar.\nLeverages FullCalendar's internal drag-n-drop functionality WITHOUT a third-party drag system.\n*/\nvar ExternalDraggable = /*#__PURE__*/function () {\n  function ExternalDraggable(el) {\n    var _this14 = this;\n    var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, ExternalDraggable);\n    this.handlePointerDown = function (ev) {\n      var dragging = _this14.dragging;\n      var _this14$settings = _this14.settings,\n        minDistance = _this14$settings.minDistance,\n        longPressDelay = _this14$settings.longPressDelay;\n      dragging.minDistance = minDistance != null ? minDistance : ev.isTouch ? 0 : BASE_OPTION_DEFAULTS.eventDragMinDistance;\n      dragging.delay = ev.isTouch ?\n      // TODO: eventually read eventLongPressDelay instead vvv\n      longPressDelay != null ? longPressDelay : BASE_OPTION_DEFAULTS.longPressDelay : 0;\n    };\n    this.handleDragStart = function (ev) {\n      if (ev.isTouch && _this14.dragging.delay && ev.subjectEl.classList.contains('fc-event')) {\n        _this14.dragging.mirror.getMirrorEl().classList.add('fc-event-selected');\n      }\n    };\n    this.settings = settings;\n    var dragging = this.dragging = new FeaturefulElementDragging(el);\n    dragging.touchScrollAllowed = false;\n    if (settings.itemSelector != null) {\n      dragging.pointer.selector = settings.itemSelector;\n    }\n    if (settings.appendTo != null) {\n      dragging.mirror.parentNode = settings.appendTo; // TODO: write tests\n    }\n\n    dragging.emitter.on('pointerdown', this.handlePointerDown);\n    dragging.emitter.on('dragstart', this.handleDragStart);\n    new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new\n  }\n  _createClass(ExternalDraggable, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.dragging.destroy();\n    }\n  }]);\n  return ExternalDraggable;\n}();\n/*\nDetects when a *THIRD-PARTY* drag-n-drop system interacts with elements.\nThe third-party system is responsible for drawing the visuals effects of the drag.\nThis class simply monitors for pointer movements and fires events.\nIt also has the ability to hide the moving element (the \"mirror\") during the drag.\n*/\nvar InferredElementDragging = /*#__PURE__*/function (_ElementDragging2) {\n  _inherits(InferredElementDragging, _ElementDragging2);\n  function InferredElementDragging(containerEl) {\n    var _this15;\n    _classCallCheck(this, InferredElementDragging);\n    _this15 = _possibleConstructorReturn(this, _getPrototypeOf(InferredElementDragging).call(this, containerEl));\n    _this15.shouldIgnoreMove = false;\n    _this15.mirrorSelector = '';\n    _this15.currentMirrorEl = null;\n    _this15.handlePointerDown = function (ev) {\n      _this15.emitter.trigger('pointerdown', ev);\n      if (!_this15.shouldIgnoreMove) {\n        // fire dragstart right away. does not support delay or min-distance\n        _this15.emitter.trigger('dragstart', ev);\n      }\n    };\n    _this15.handlePointerMove = function (ev) {\n      if (!_this15.shouldIgnoreMove) {\n        _this15.emitter.trigger('dragmove', ev);\n      }\n    };\n    _this15.handlePointerUp = function (ev) {\n      _this15.emitter.trigger('pointerup', ev);\n      if (!_this15.shouldIgnoreMove) {\n        // fire dragend right away. does not support a revert animation\n        _this15.emitter.trigger('dragend', ev);\n      }\n    };\n    var pointer = _this15.pointer = new PointerDragging(containerEl);\n    pointer.emitter.on('pointerdown', _this15.handlePointerDown);\n    pointer.emitter.on('pointermove', _this15.handlePointerMove);\n    pointer.emitter.on('pointerup', _this15.handlePointerUp);\n    return _this15;\n  }\n  _createClass(InferredElementDragging, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.pointer.destroy();\n    }\n  }, {\n    key: \"setIgnoreMove\",\n    value: function setIgnoreMove(bool) {\n      this.shouldIgnoreMove = bool;\n    }\n  }, {\n    key: \"setMirrorIsVisible\",\n    value: function setMirrorIsVisible(bool) {\n      if (bool) {\n        // restore a previously hidden element.\n        // use the reference in case the selector class has already been removed.\n        if (this.currentMirrorEl) {\n          this.currentMirrorEl.style.visibility = '';\n          this.currentMirrorEl = null;\n        }\n      } else {\n        var mirrorEl = this.mirrorSelector\n        // TODO: somehow query FullCalendars WITHIN shadow-roots\n        ? document.querySelector(this.mirrorSelector) : null;\n        if (mirrorEl) {\n          this.currentMirrorEl = mirrorEl;\n          mirrorEl.style.visibility = 'hidden';\n        }\n      }\n    }\n  }]);\n  return InferredElementDragging;\n}(ElementDragging);\n/*\nBridges third-party drag-n-drop systems with FullCalendar.\nMust be instantiated and destroyed by caller.\n*/\nvar ThirdPartyDraggable = /*#__PURE__*/function () {\n  function ThirdPartyDraggable(containerOrSettings, settings) {\n    _classCallCheck(this, ThirdPartyDraggable);\n    var containerEl = document;\n    if (\n    // wish we could just test instanceof EventTarget, but doesn't work in IE11\n    containerOrSettings === document || containerOrSettings instanceof Element) {\n      containerEl = containerOrSettings;\n      settings = settings || {};\n    } else {\n      settings = containerOrSettings || {};\n    }\n    var dragging = this.dragging = new InferredElementDragging(containerEl);\n    if (typeof settings.itemSelector === 'string') {\n      dragging.pointer.selector = settings.itemSelector;\n    } else if (containerEl === document) {\n      dragging.pointer.selector = '[data-event]';\n    }\n    if (typeof settings.mirrorSelector === 'string') {\n      dragging.mirrorSelector = settings.mirrorSelector;\n    }\n    new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new\n  }\n  _createClass(ThirdPartyDraggable, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.dragging.destroy();\n    }\n  }]);\n  return ThirdPartyDraggable;\n}();\nvar index = createPlugin({\n  name: '@fullcalendar/interaction',\n  componentInteractions: [DateClicking, DateSelecting, EventDragging, EventResizing],\n  calendarInteractions: [UnselectAuto],\n  elementDraggingImpl: FeaturefulElementDragging,\n  optionRefiners: OPTION_REFINERS,\n  listenerRefiners: LISTENER_REFINERS\n});\nexport { ExternalDraggable as Draggable, ThirdPartyDraggable, index as default };","map":null,"metadata":{},"sourceType":"module"}