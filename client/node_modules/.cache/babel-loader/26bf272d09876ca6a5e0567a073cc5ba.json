{"ast":null,"code":"import _assertThisInitialized from \"C:\\\\Users\\\\ASUS VivoBook\\\\Desktop\\\\PI - Copie\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _toConsumableArray from \"C:\\\\Users\\\\ASUS VivoBook\\\\Desktop\\\\PI - Copie\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"C:\\\\Users\\\\ASUS VivoBook\\\\Desktop\\\\PI - Copie\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\ASUS VivoBook\\\\Desktop\\\\PI - Copie\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\ASUS VivoBook\\\\Desktop\\\\PI - Copie\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\ASUS VivoBook\\\\Desktop\\\\PI - Copie\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\ASUS VivoBook\\\\Desktop\\\\PI - Copie\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nimport { Splitter, hasBgRendering, createFormatter, ViewContextType, ContentContainer, BaseComponent, DateComponent, diffDays, buildNavLinkAttrs, WeekNumberContainer, getStickyHeaderDates, ViewContainer, SimpleScrollGrid, getStickyFooterScrollbar, NowTimer, NowIndicatorContainer, renderScrollShim, rangeContainsMarker, startOfDay, asRoughMs, createDuration, RefMap, PositionCache, MoreLinkContainer, SegHierarchy, groupIntersectingEntries, binarySearch, getEntrySpanEnd, buildEntryKey, StandardEvent, memoize, sortEventSegs, DayCellContainer, hasCustomDayCellContent, getSegMeta, buildIsoString, computeEarliestSegStart, buildEventRangeKey, BgEvent, renderFill, addDurations, multiplyDuration, wholeDivideDurations, Slicer, intersectRanges, formatIsoTimeString, DayHeader, DaySeriesModel, DayTableModel, injectStyles } from '@fullcalendar/core/internal.js';\nimport { createElement, createRef, Fragment } from '@fullcalendar/core/preact.js';\nimport { DayTable } from '@fullcalendar/daygrid/internal.js';\nvar AllDaySplitter = /*#__PURE__*/function (_Splitter) {\n  _inherits(AllDaySplitter, _Splitter);\n  function AllDaySplitter() {\n    _classCallCheck(this, AllDaySplitter);\n    return _possibleConstructorReturn(this, _getPrototypeOf(AllDaySplitter).apply(this, arguments));\n  }\n  _createClass(AllDaySplitter, [{\n    key: \"getKeyInfo\",\n    value: function getKeyInfo() {\n      return {\n        allDay: {},\n        timed: {}\n      };\n    }\n  }, {\n    key: \"getKeysForDateSpan\",\n    value: function getKeysForDateSpan(dateSpan) {\n      if (dateSpan.allDay) {\n        return ['allDay'];\n      }\n      return ['timed'];\n    }\n  }, {\n    key: \"getKeysForEventDef\",\n    value: function getKeysForEventDef(eventDef) {\n      if (!eventDef.allDay) {\n        return ['timed'];\n      }\n      if (hasBgRendering(eventDef)) {\n        return ['timed', 'allDay'];\n      }\n      return ['allDay'];\n    }\n  }]);\n  return AllDaySplitter;\n}(Splitter);\nvar DEFAULT_SLAT_LABEL_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'short'\n});\nfunction TimeColsAxisCell(props) {\n  var classNames = ['fc-timegrid-slot', 'fc-timegrid-slot-label', props.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor'];\n  return createElement(ViewContextType.Consumer, null, function (context) {\n    if (!props.isLabeled) {\n      return createElement(\"td\", {\n        className: classNames.join(' '),\n        \"data-time\": props.isoTimeStr\n      });\n    }\n    var dateEnv = context.dateEnv,\n      options = context.options,\n      viewApi = context.viewApi;\n    var labelFormat =\n    // TODO: fully pre-parse\n    options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) : createFormatter(options.slotLabelFormat);\n    var renderProps = {\n      level: 0,\n      time: props.time,\n      date: dateEnv.toDate(props.date),\n      view: viewApi,\n      text: dateEnv.format(props.date, labelFormat)\n    };\n    return createElement(ContentContainer, {\n      elTag: \"td\",\n      elClasses: classNames,\n      elAttrs: {\n        'data-time': props.isoTimeStr\n      },\n      renderProps: renderProps,\n      generatorName: \"slotLabelContent\",\n      customGenerator: options.slotLabelContent,\n      defaultGenerator: renderInnerContent,\n      classNameGenerator: options.slotLabelClassNames,\n      didMount: options.slotLabelDidMount,\n      willUnmount: options.slotLabelWillUnmount\n    }, function (InnerContent) {\n      return createElement(\"div\", {\n        className: \"fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame\"\n      }, createElement(InnerContent, {\n        elTag: \"div\",\n        elClasses: ['fc-timegrid-slot-label-cushion', 'fc-scrollgrid-shrink-cushion']\n      }));\n    });\n  });\n}\nfunction renderInnerContent(props) {\n  return props.text;\n}\nvar TimeBodyAxis = /*#__PURE__*/function (_BaseComponent) {\n  _inherits(TimeBodyAxis, _BaseComponent);\n  function TimeBodyAxis() {\n    _classCallCheck(this, TimeBodyAxis);\n    return _possibleConstructorReturn(this, _getPrototypeOf(TimeBodyAxis).apply(this, arguments));\n  }\n  _createClass(TimeBodyAxis, [{\n    key: \"render\",\n    value: function render() {\n      return this.props.slatMetas.map(function (slatMeta) {\n        return createElement(\"tr\", {\n          key: slatMeta.key\n        }, createElement(TimeColsAxisCell, Object.assign({}, slatMeta)));\n      });\n    }\n  }]);\n  return TimeBodyAxis;\n}(BaseComponent);\nvar DEFAULT_WEEK_NUM_FORMAT = createFormatter({\n  week: 'short'\n});\nvar AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;\nvar TimeColsView = /*#__PURE__*/function (_DateComponent) {\n  _inherits(TimeColsView, _DateComponent);\n  function TimeColsView() {\n    var _this;\n    _classCallCheck(this, TimeColsView);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TimeColsView).apply(this, arguments));\n    _this.allDaySplitter = new AllDaySplitter(); // for use by subclasses\n    _this.headerElRef = createRef();\n    _this.rootElRef = createRef();\n    _this.scrollerElRef = createRef();\n    _this.state = {\n      slatCoords: null\n    };\n    _this.handleScrollTopRequest = function (scrollTop) {\n      var scrollerEl = _this.scrollerElRef.current;\n      if (scrollerEl) {\n        // TODO: not sure how this could ever be null. weirdness with the reducer\n        scrollerEl.scrollTop = scrollTop;\n      }\n    };\n    /* Header Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n    _this.renderHeadAxis = function (rowKey) {\n      var frameHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var options = _this.context.options;\n      var dateProfile = _this.props.dateProfile;\n      var range = dateProfile.renderRange;\n      var dayCnt = diffDays(range.start, range.end);\n      // only do in day views (to avoid doing in week views that dont need it)\n      var navLinkAttrs = dayCnt === 1 ? buildNavLinkAttrs(_this.context, range.start, 'week') : {};\n      if (options.weekNumbers && rowKey === 'day') {\n        return createElement(WeekNumberContainer, {\n          elTag: \"th\",\n          elClasses: ['fc-timegrid-axis', 'fc-scrollgrid-shrink'],\n          elAttrs: {\n            'aria-hidden': true\n          },\n          date: range.start,\n          defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n        }, function (InnerContent) {\n          return createElement(\"div\", {\n            className: ['fc-timegrid-axis-frame', 'fc-scrollgrid-shrink-frame', 'fc-timegrid-axis-frame-liquid'].join(' '),\n            style: {\n              height: frameHeight\n            }\n          }, createElement(InnerContent, {\n            elTag: \"a\",\n            elClasses: ['fc-timegrid-axis-cushion', 'fc-scrollgrid-shrink-cushion', 'fc-scrollgrid-sync-inner'],\n            elAttrs: navLinkAttrs\n          }));\n        });\n      }\n      return createElement(\"th\", {\n        \"aria-hidden\": true,\n        className: \"fc-timegrid-axis\"\n      }, createElement(\"div\", {\n        className: \"fc-timegrid-axis-frame\",\n        style: {\n          height: frameHeight\n        }\n      }));\n    };\n    /* Table Component Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n    // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,\n    // but DayGrid still needs to have classNames on inner elements in order to measure.\n    _this.renderTableRowAxis = function (rowHeight) {\n      var _this$context = _this.context,\n        options = _this$context.options,\n        viewApi = _this$context.viewApi;\n      var renderProps = {\n        text: options.allDayText,\n        view: viewApi\n      };\n      return (\n        // TODO: make reusable hook. used in list view too\n        createElement(ContentContainer, {\n          elTag: \"td\",\n          elClasses: ['fc-timegrid-axis', 'fc-scrollgrid-shrink'],\n          elAttrs: {\n            'aria-hidden': true\n          },\n          renderProps: renderProps,\n          generatorName: \"allDayContent\",\n          customGenerator: options.allDayContent,\n          defaultGenerator: renderAllDayInner,\n          classNameGenerator: options.allDayClassNames,\n          didMount: options.allDayDidMount,\n          willUnmount: options.allDayWillUnmount\n        }, function (InnerContent) {\n          return createElement(\"div\", {\n            className: ['fc-timegrid-axis-frame', 'fc-scrollgrid-shrink-frame', rowHeight == null ? ' fc-timegrid-axis-frame-liquid' : ''].join(' '),\n            style: {\n              height: rowHeight\n            }\n          }, createElement(InnerContent, {\n            elTag: \"span\",\n            elClasses: ['fc-timegrid-axis-cushion', 'fc-scrollgrid-shrink-cushion', 'fc-scrollgrid-sync-inner']\n          }));\n        })\n      );\n    };\n    _this.handleSlatCoords = function (slatCoords) {\n      _this.setState({\n        slatCoords: slatCoords\n      });\n    };\n    return _this;\n  }\n  // rendering\n  // ----------------------------------------------------------------------------------------------------\n  _createClass(TimeColsView, [{\n    key: \"renderSimpleLayout\",\n    value: function renderSimpleLayout(headerRowContent, allDayContent, timeContent) {\n      var context = this.context,\n        props = this.props;\n      var sections = [];\n      var stickyHeaderDates = getStickyHeaderDates(context.options);\n      if (headerRowContent) {\n        sections.push({\n          type: 'header',\n          key: 'header',\n          isSticky: stickyHeaderDates,\n          chunk: {\n            elRef: this.headerElRef,\n            tableClassName: 'fc-col-header',\n            rowContent: headerRowContent\n          }\n        });\n      }\n      if (allDayContent) {\n        sections.push({\n          type: 'body',\n          key: 'all-day',\n          chunk: {\n            content: allDayContent\n          }\n        });\n        sections.push({\n          type: 'body',\n          key: 'all-day-divider',\n          outerContent:\n          // TODO: rename to cellContent so don't need to define <tr>?\n          createElement(\"tr\", {\n            role: \"presentation\",\n            className: \"fc-scrollgrid-section\"\n          }, createElement(\"td\", {\n            className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')\n          }))\n        });\n      }\n      sections.push({\n        type: 'body',\n        key: 'body',\n        liquid: true,\n        expandRows: Boolean(context.options.expandRows),\n        chunk: {\n          scrollerElRef: this.scrollerElRef,\n          content: timeContent\n        }\n      });\n      return createElement(ViewContainer, {\n        elRef: this.rootElRef,\n        elClasses: ['fc-timegrid'],\n        viewSpec: context.viewSpec\n      }, createElement(SimpleScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: props.forPrint,\n        cols: [{\n          width: 'shrink'\n        }],\n        sections: sections\n      }));\n    }\n  }, {\n    key: \"renderHScrollLayout\",\n    value: function renderHScrollLayout(headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {\n      var _this2 = this;\n      var ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n      if (!ScrollGrid) {\n        throw new Error('No ScrollGrid implementation');\n      }\n      var context = this.context,\n        props = this.props;\n      var stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);\n      var stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);\n      var sections = [];\n      if (headerRowContent) {\n        sections.push({\n          type: 'header',\n          key: 'header',\n          isSticky: stickyHeaderDates,\n          syncRowHeights: true,\n          chunks: [{\n            key: 'axis',\n            rowContent: function rowContent(arg) {\n              return createElement(\"tr\", {\n                role: \"presentation\"\n              }, _this2.renderHeadAxis('day', arg.rowSyncHeights[0]));\n            }\n          }, {\n            key: 'cols',\n            elRef: this.headerElRef,\n            tableClassName: 'fc-col-header',\n            rowContent: headerRowContent\n          }]\n        });\n      }\n      if (allDayContent) {\n        sections.push({\n          type: 'body',\n          key: 'all-day',\n          syncRowHeights: true,\n          chunks: [{\n            key: 'axis',\n            rowContent: function rowContent(contentArg) {\n              return createElement(\"tr\", {\n                role: \"presentation\"\n              }, _this2.renderTableRowAxis(contentArg.rowSyncHeights[0]));\n            }\n          }, {\n            key: 'cols',\n            content: allDayContent\n          }]\n        });\n        sections.push({\n          key: 'all-day-divider',\n          type: 'body',\n          outerContent:\n          // TODO: rename to cellContent so don't need to define <tr>?\n          createElement(\"tr\", {\n            role: \"presentation\",\n            className: \"fc-scrollgrid-section\"\n          }, createElement(\"td\", {\n            colSpan: 2,\n            className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')\n          }))\n        });\n      }\n      var isNowIndicator = context.options.nowIndicator;\n      sections.push({\n        type: 'body',\n        key: 'body',\n        liquid: true,\n        expandRows: Boolean(context.options.expandRows),\n        chunks: [{\n          key: 'axis',\n          content: function content(arg) {\n            return (\n              // TODO: make this now-indicator arrow more DRY with TimeColsContent\n              createElement(\"div\", {\n                className: \"fc-timegrid-axis-chunk\"\n              }, createElement(\"table\", {\n                \"aria-hidden\": true,\n                style: {\n                  height: arg.expandRows ? arg.clientHeight : ''\n                }\n              }, arg.tableColGroupNode, createElement(\"tbody\", null, createElement(TimeBodyAxis, {\n                slatMetas: slatMetas\n              }))), createElement(\"div\", {\n                className: \"fc-timegrid-now-indicator-container\"\n              }, createElement(NowTimer, {\n                unit: isNowIndicator ? 'minute' : 'day' /* hacky */\n              }, function (nowDate) {\n                var nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate); // might return void\n                if (typeof nowIndicatorTop === 'number') {\n                  return createElement(NowIndicatorContainer, {\n                    elClasses: ['fc-timegrid-now-indicator-arrow'],\n                    elStyle: {\n                      top: nowIndicatorTop\n                    },\n                    isAxis: true,\n                    date: nowDate\n                  });\n                }\n                return null;\n              })))\n            );\n          }\n        }, {\n          key: 'cols',\n          scrollerElRef: this.scrollerElRef,\n          content: timeContent\n        }]\n      });\n      if (stickyFooterScrollbar) {\n        sections.push({\n          key: 'footer',\n          type: 'footer',\n          isSticky: true,\n          chunks: [{\n            key: 'axis',\n            content: renderScrollShim\n          }, {\n            key: 'cols',\n            content: renderScrollShim\n          }]\n        });\n      }\n      return createElement(ViewContainer, {\n        elRef: this.rootElRef,\n        elClasses: ['fc-timegrid'],\n        viewSpec: context.viewSpec\n      }, createElement(ScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        forPrint: props.forPrint,\n        collapsibleWidth: false,\n        colGroups: [{\n          width: 'shrink',\n          cols: [{\n            width: 'shrink'\n          }]\n        }, {\n          cols: [{\n            span: colCnt,\n            minWidth: dayMinWidth\n          }]\n        }],\n        sections: sections\n      }));\n    }\n    /* Dimensions\n    ------------------------------------------------------------------------------------------------------------------*/\n  }, {\n    key: \"getAllDayMaxEventProps\",\n    value: function getAllDayMaxEventProps() {\n      var _this$context$options = this.context.options,\n        dayMaxEvents = _this$context$options.dayMaxEvents,\n        dayMaxEventRows = _this$context$options.dayMaxEventRows;\n      if (dayMaxEvents === true || dayMaxEventRows === true) {\n        // is auto?\n        dayMaxEvents = undefined;\n        dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS; // make sure \"auto\" goes to a real number\n      }\n\n      return {\n        dayMaxEvents: dayMaxEvents,\n        dayMaxEventRows: dayMaxEventRows\n      };\n    }\n  }]);\n  return TimeColsView;\n}(DateComponent);\nfunction renderAllDayInner(renderProps) {\n  return renderProps.text;\n}\nvar TimeColsSlatsCoords = /*#__PURE__*/function () {\n  function TimeColsSlatsCoords(positions, dateProfile, slotDuration) {\n    _classCallCheck(this, TimeColsSlatsCoords);\n    this.positions = positions;\n    this.dateProfile = dateProfile;\n    this.slotDuration = slotDuration;\n  }\n  _createClass(TimeColsSlatsCoords, [{\n    key: \"safeComputeTop\",\n    value: function safeComputeTop(date) {\n      var dateProfile = this.dateProfile;\n      if (rangeContainsMarker(dateProfile.currentRange, date)) {\n        var startOfDayDate = startOfDay(date);\n        var timeMs = date.valueOf() - startOfDayDate.valueOf();\n        if (timeMs >= asRoughMs(dateProfile.slotMinTime) && timeMs < asRoughMs(dateProfile.slotMaxTime)) {\n          return this.computeTimeTop(createDuration(timeMs));\n        }\n      }\n      return null;\n    } // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n    // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n  }, {\n    key: \"computeDateTop\",\n    value: function computeDateTop(when, startOfDayDate) {\n      if (!startOfDayDate) {\n        startOfDayDate = startOfDay(when);\n      }\n      return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()));\n    } // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n    // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.\n    // Eventually allow computation with arbirary slat dates.\n  }, {\n    key: \"computeTimeTop\",\n    value: function computeTimeTop(duration) {\n      var positions = this.positions,\n        dateProfile = this.dateProfile;\n      var len = positions.els.length;\n      // floating-point value of # of slots covered\n      var slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.slotMinTime)) / asRoughMs(this.slotDuration);\n      var slatIndex;\n      var slatRemainder;\n      // compute a floating-point number for how many slats should be progressed through.\n      // from 0 to number of slats (inclusive)\n      // constrained because slotMinTime/slotMaxTime might be customized.\n      slatCoverage = Math.max(0, slatCoverage);\n      slatCoverage = Math.min(len, slatCoverage);\n      // an integer index of the furthest whole slat\n      // from 0 to number slats (*exclusive*, so len-1)\n      slatIndex = Math.floor(slatCoverage);\n      slatIndex = Math.min(slatIndex, len - 1);\n      // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n      // could be 1.0 if slatCoverage is covering *all* the slots\n      slatRemainder = slatCoverage - slatIndex;\n      return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;\n    }\n  }]);\n  return TimeColsSlatsCoords;\n}();\nvar TimeColsSlatsBody = /*#__PURE__*/function (_BaseComponent2) {\n  _inherits(TimeColsSlatsBody, _BaseComponent2);\n  function TimeColsSlatsBody() {\n    _classCallCheck(this, TimeColsSlatsBody);\n    return _possibleConstructorReturn(this, _getPrototypeOf(TimeColsSlatsBody).apply(this, arguments));\n  }\n  _createClass(TimeColsSlatsBody, [{\n    key: \"render\",\n    value: function render() {\n      var props = this.props,\n        context = this.context;\n      var options = context.options;\n      var slatElRefs = props.slatElRefs;\n      return createElement(\"tbody\", null, props.slatMetas.map(function (slatMeta, i) {\n        var renderProps = {\n          time: slatMeta.time,\n          date: context.dateEnv.toDate(slatMeta.date),\n          view: context.viewApi\n        };\n        return createElement(\"tr\", {\n          key: slatMeta.key,\n          ref: slatElRefs.createRef(slatMeta.key)\n        }, props.axis && createElement(TimeColsAxisCell, Object.assign({}, slatMeta)), createElement(ContentContainer, {\n          elTag: \"td\",\n          elClasses: ['fc-timegrid-slot', 'fc-timegrid-slot-lane', !slatMeta.isLabeled && 'fc-timegrid-slot-minor'],\n          elAttrs: {\n            'data-time': slatMeta.isoTimeStr\n          },\n          renderProps: renderProps,\n          generatorName: \"slotLaneContent\",\n          customGenerator: options.slotLaneContent,\n          classNameGenerator: options.slotLaneClassNames,\n          didMount: options.slotLaneDidMount,\n          willUnmount: options.slotLaneWillUnmount\n        }));\n      }));\n    }\n  }]);\n  return TimeColsSlatsBody;\n}(BaseComponent);\n/*\nfor the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n*/\nvar TimeColsSlats = /*#__PURE__*/function (_BaseComponent3) {\n  _inherits(TimeColsSlats, _BaseComponent3);\n  function TimeColsSlats() {\n    var _this3;\n    _classCallCheck(this, TimeColsSlats);\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(TimeColsSlats).apply(this, arguments));\n    _this3.rootElRef = createRef();\n    _this3.slatElRefs = new RefMap();\n    return _this3;\n  }\n  _createClass(TimeColsSlats, [{\n    key: \"render\",\n    value: function render() {\n      var props = this.props,\n        context = this.context;\n      return createElement(\"div\", {\n        ref: this.rootElRef,\n        className: \"fc-timegrid-slots\"\n      }, createElement(\"table\", {\n        \"aria-hidden\": true,\n        className: context.theme.getClass('table'),\n        style: {\n          minWidth: props.tableMinWidth,\n          width: props.clientWidth,\n          height: props.minHeight\n        }\n      }, props.tableColGroupNode /* relies on there only being a single <col> for the axis */, createElement(TimeColsSlatsBody, {\n        slatElRefs: this.slatElRefs,\n        axis: props.axis,\n        slatMetas: props.slatMetas\n      })));\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.updateSizing();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.updateSizing();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.props.onCoords) {\n        this.props.onCoords(null);\n      }\n    }\n  }, {\n    key: \"updateSizing\",\n    value: function updateSizing() {\n      var context = this.context,\n        props = this.props;\n      if (props.onCoords && props.clientWidth !== null // means sizing has stabilized\n      ) {\n        var rootEl = this.rootElRef.current;\n        if (rootEl.offsetHeight) {\n          // not hidden by css\n          props.onCoords(new TimeColsSlatsCoords(new PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));\n        }\n      }\n    }\n  }]);\n  return TimeColsSlats;\n}(BaseComponent);\nfunction collectSlatEls(elMap, slatMetas) {\n  return slatMetas.map(function (slatMeta) {\n    return elMap[slatMeta.key];\n  });\n}\nfunction splitSegsByCol(segs, colCnt) {\n  var segsByCol = [];\n  var i;\n  for (i = 0; i < colCnt; i += 1) {\n    segsByCol.push([]);\n  }\n  if (segs) {\n    for (i = 0; i < segs.length; i += 1) {\n      segsByCol[segs[i].col].push(segs[i]);\n    }\n  }\n  return segsByCol;\n}\nfunction splitInteractionByCol(ui, colCnt) {\n  var byRow = [];\n  if (!ui) {\n    for (var i = 0; i < colCnt; i += 1) {\n      byRow[i] = null;\n    }\n  } else {\n    for (var _i = 0; _i < colCnt; _i += 1) {\n      byRow[_i] = {\n        affectedInstances: ui.affectedInstances,\n        isEvent: ui.isEvent,\n        segs: []\n      };\n    }\n    var _iterator = _createForOfIteratorHelper(ui.segs),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var seg = _step.value;\n        byRow[seg.col].segs.push(seg);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return byRow;\n}\nvar TimeColMoreLink = /*#__PURE__*/function (_BaseComponent4) {\n  _inherits(TimeColMoreLink, _BaseComponent4);\n  function TimeColMoreLink() {\n    _classCallCheck(this, TimeColMoreLink);\n    return _possibleConstructorReturn(this, _getPrototypeOf(TimeColMoreLink).apply(this, arguments));\n  }\n  _createClass(TimeColMoreLink, [{\n    key: \"render\",\n    value: function render() {\n      var props = this.props;\n      return createElement(MoreLinkContainer, {\n        elClasses: ['fc-timegrid-more-link'],\n        elStyle: {\n          top: props.top,\n          bottom: props.bottom\n        },\n        allDayDate: null,\n        moreCnt: props.hiddenSegs.length,\n        allSegs: props.hiddenSegs,\n        hiddenSegs: props.hiddenSegs,\n        extraDateSpan: props.extraDateSpan,\n        dateProfile: props.dateProfile,\n        todayRange: props.todayRange,\n        popoverContent: function popoverContent() {\n          return renderPlainFgSegs(props.hiddenSegs, props);\n        },\n        defaultGenerator: renderMoreLinkInner,\n        forceTimed: true\n      }, function (InnerContent) {\n        return createElement(InnerContent, {\n          elTag: \"div\",\n          elClasses: ['fc-timegrid-more-link-inner', 'fc-sticky']\n        });\n      });\n    }\n  }]);\n  return TimeColMoreLink;\n}(BaseComponent);\nfunction renderMoreLinkInner(props) {\n  return props.shortText;\n}\n\n// segInputs assumed sorted\nfunction buildPositioning(segInputs, strictOrder, maxStackCnt) {\n  var hierarchy = new SegHierarchy();\n  if (strictOrder != null) {\n    hierarchy.strictOrder = strictOrder;\n  }\n  if (maxStackCnt != null) {\n    hierarchy.maxStackCnt = maxStackCnt;\n  }\n  var hiddenEntries = hierarchy.addSegs(segInputs);\n  var hiddenGroups = groupIntersectingEntries(hiddenEntries);\n  var web = buildWeb(hierarchy);\n  web = stretchWeb(web, 1); // all levelCoords/thickness will have 0.0-1.0\n  var segRects = webToRects(web);\n  return {\n    segRects: segRects,\n    hiddenGroups: hiddenGroups\n  };\n}\nfunction buildWeb(hierarchy) {\n  var entriesByLevel = hierarchy.entriesByLevel;\n  var buildNode = cacheable(function (level, lateral) {\n    return level + ':' + lateral;\n  }, function (level, lateral) {\n    var siblingRange = findNextLevelSegs(hierarchy, level, lateral);\n    var nextLevelRes = buildNodes(siblingRange, buildNode);\n    var entry = entriesByLevel[level][lateral];\n    return [Object.assign(Object.assign({}, entry), {\n      nextLevelNodes: nextLevelRes[0]\n    }), entry.thickness + nextLevelRes[1] // the pressure builds\n    ];\n  });\n\n  return buildNodes(entriesByLevel.length ? {\n    level: 0,\n    lateralStart: 0,\n    lateralEnd: entriesByLevel[0].length\n  } : null, buildNode)[0];\n}\nfunction buildNodes(siblingRange, buildNode) {\n  if (!siblingRange) {\n    return [[], 0];\n  }\n  var level = siblingRange.level,\n    lateralStart = siblingRange.lateralStart,\n    lateralEnd = siblingRange.lateralEnd;\n  var lateral = lateralStart;\n  var pairs = [];\n  while (lateral < lateralEnd) {\n    pairs.push(buildNode(level, lateral));\n    lateral += 1;\n  }\n  pairs.sort(cmpDescPressures);\n  return [pairs.map(extractNode), pairs[0][1] // first item's pressure\n  ];\n}\n\nfunction cmpDescPressures(a, b) {\n  return b[1] - a[1];\n}\nfunction extractNode(a) {\n  return a[0];\n}\nfunction findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {\n  var levelCoords = hierarchy.levelCoords,\n    entriesByLevel = hierarchy.entriesByLevel;\n  var subjectEntry = entriesByLevel[subjectLevel][subjectLateral];\n  var afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;\n  var levelCnt = levelCoords.length;\n  var level = subjectLevel;\n  // skip past levels that are too high up\n  for (; level < levelCnt && levelCoords[level] < afterSubject; level += 1); // do nothing\n  for (; level < levelCnt; level += 1) {\n    var entries = entriesByLevel[level];\n    var entry = void 0;\n    var searchIndex = binarySearch(entries, subjectEntry.span.start, getEntrySpanEnd);\n    var lateralStart = searchIndex[0] + searchIndex[1]; // if exact match (which doesn't collide), go to next one\n    var lateralEnd = lateralStart;\n    while (\n    // loop through entries that horizontally intersect\n    (entry = entries[lateralEnd]) &&\n    // but not past the whole seg list\n    entry.span.start < subjectEntry.span.end) {\n      lateralEnd += 1;\n    }\n    if (lateralStart < lateralEnd) {\n      return {\n        level: level,\n        lateralStart: lateralStart,\n        lateralEnd: lateralEnd\n      };\n    }\n  }\n  return null;\n}\nfunction stretchWeb(topLevelNodes, totalThickness) {\n  var stretchNode = cacheable(function (node, startCoord, prevThickness) {\n    return buildEntryKey(node);\n  }, function (node, startCoord, prevThickness) {\n    var nextLevelNodes = node.nextLevelNodes,\n      thickness = node.thickness;\n    var allThickness = thickness + prevThickness;\n    var thicknessFraction = thickness / allThickness;\n    var endCoord;\n    var newChildren = [];\n    if (!nextLevelNodes.length) {\n      endCoord = totalThickness;\n    } else {\n      var _iterator2 = _createForOfIteratorHelper(nextLevelNodes),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var childNode = _step2.value;\n          if (endCoord === undefined) {\n            var res = stretchNode(childNode, startCoord, allThickness);\n            endCoord = res[0];\n            newChildren.push(res[1]);\n          } else {\n            var _res = stretchNode(childNode, endCoord, 0);\n            newChildren.push(_res[1]);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    var newThickness = (endCoord - startCoord) * thicknessFraction;\n    return [endCoord - newThickness, Object.assign(Object.assign({}, node), {\n      thickness: newThickness,\n      nextLevelNodes: newChildren\n    })];\n  });\n  return topLevelNodes.map(function (node) {\n    return stretchNode(node, 0, 0)[1];\n  });\n}\n// not sorted in any particular order\nfunction webToRects(topLevelNodes) {\n  var rects = [];\n  var processNode = cacheable(function (node, levelCoord, stackDepth) {\n    return buildEntryKey(node);\n  }, function (node, levelCoord, stackDepth) {\n    var rect = Object.assign(Object.assign({}, node), {\n      levelCoord: levelCoord,\n      stackDepth: stackDepth,\n      stackForward: 0\n    });\n    rects.push(rect);\n    return rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1;\n  });\n  function processNodes(nodes, levelCoord, stackDepth) {\n    var stackForward = 0;\n    var _iterator3 = _createForOfIteratorHelper(nodes),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var node = _step3.value;\n        stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    return stackForward;\n  }\n  processNodes(topLevelNodes, 0, 0);\n  return rects; // TODO: sort rects by levelCoord to be consistent with toRects?\n}\n// TODO: move to general util\nfunction cacheable(keyFunc, workFunc) {\n  var cache = {};\n  return function () {\n    var key = keyFunc.apply(void 0, arguments);\n    return key in cache ? cache[key] : cache[key] = workFunc.apply(void 0, arguments);\n  };\n}\nfunction computeSegVCoords(segs, colDate) {\n  var slatCoords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var eventMinHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var vcoords = [];\n  if (slatCoords) {\n    for (var i = 0; i < segs.length; i += 1) {\n      var seg = segs[i];\n      var spanStart = slatCoords.computeDateTop(seg.start, colDate);\n      var spanEnd = Math.max(spanStart + (eventMinHeight || 0),\n      // :(\n      slatCoords.computeDateTop(seg.end, colDate));\n      vcoords.push({\n        start: Math.round(spanStart),\n        end: Math.round(spanEnd) //\n      });\n    }\n  }\n\n  return vcoords;\n}\nfunction computeFgSegPlacements(segs, segVCoords,\n// might not have for every seg\neventOrderStrict, eventMaxStack) {\n  var segInputs = [];\n  var dumbSegs = []; // segs without coords\n  for (var i = 0; i < segs.length; i += 1) {\n    var vcoords = segVCoords[i];\n    if (vcoords) {\n      segInputs.push({\n        index: i,\n        thickness: 1,\n        span: vcoords\n      });\n    } else {\n      dumbSegs.push(segs[i]);\n    }\n  }\n  var _buildPositioning = buildPositioning(segInputs, eventOrderStrict, eventMaxStack),\n    segRects = _buildPositioning.segRects,\n    hiddenGroups = _buildPositioning.hiddenGroups;\n  var segPlacements = [];\n  var _iterator4 = _createForOfIteratorHelper(segRects),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var segRect = _step4.value;\n      segPlacements.push({\n        seg: segs[segRect.index],\n        rect: segRect\n      });\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  for (var _i2 = 0, _dumbSegs = dumbSegs; _i2 < _dumbSegs.length; _i2++) {\n    var dumbSeg = _dumbSegs[_i2];\n    segPlacements.push({\n      seg: dumbSeg,\n      rect: null\n    });\n  }\n  return {\n    segPlacements: segPlacements,\n    hiddenGroups: hiddenGroups\n  };\n}\nvar DEFAULT_TIME_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  meridiem: false\n});\nvar TimeColEvent = /*#__PURE__*/function (_BaseComponent5) {\n  _inherits(TimeColEvent, _BaseComponent5);\n  function TimeColEvent() {\n    _classCallCheck(this, TimeColEvent);\n    return _possibleConstructorReturn(this, _getPrototypeOf(TimeColEvent).apply(this, arguments));\n  }\n  _createClass(TimeColEvent, [{\n    key: \"render\",\n    value: function render() {\n      return createElement(StandardEvent, Object.assign({}, this.props, {\n        elClasses: ['fc-timegrid-event', 'fc-v-event', this.props.isShort && 'fc-timegrid-event-short'],\n        defaultTimeFormat: DEFAULT_TIME_FORMAT\n      }));\n    }\n  }]);\n  return TimeColEvent;\n}(BaseComponent);\nvar TimeCol = /*#__PURE__*/function (_BaseComponent6) {\n  _inherits(TimeCol, _BaseComponent6);\n  function TimeCol() {\n    var _this4;\n    _classCallCheck(this, TimeCol);\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(TimeCol).apply(this, arguments));\n    _this4.sortEventSegs = memoize(sortEventSegs);\n    return _this4;\n  }\n  // TODO: memoize event-placement?\n  _createClass(TimeCol, [{\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n      var props = this.props,\n        context = this.context;\n      var options = context.options;\n      var isSelectMirror = options.selectMirror;\n      var mirrorSegs =\n      // yuck\n      props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || [];\n      var interactionAffectedInstances =\n      // TODO: messy way to compute this\n      props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n      var sortedFgSegs = this.sortEventSegs(props.fgEventSegs, options.eventOrder);\n      return createElement(DayCellContainer, {\n        elTag: \"td\",\n        elRef: props.elRef,\n        elClasses: ['fc-timegrid-col'].concat(_toConsumableArray(props.extraClassNames || [])),\n        elAttrs: Object.assign({\n          role: 'gridcell'\n        }, props.extraDataAttrs),\n        date: props.date,\n        dateProfile: props.dateProfile,\n        todayRange: props.todayRange,\n        extraRenderProps: props.extraRenderProps\n      }, function (InnerContent) {\n        return createElement(\"div\", {\n          className: \"fc-timegrid-col-frame\"\n        }, createElement(\"div\", {\n          className: \"fc-timegrid-col-bg\"\n        }, _this5.renderFillSegs(props.businessHourSegs, 'non-business'), _this5.renderFillSegs(props.bgEventSegs, 'bg-event'), _this5.renderFillSegs(props.dateSelectionSegs, 'highlight')), createElement(\"div\", {\n          className: \"fc-timegrid-col-events\"\n        }, _this5.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)), createElement(\"div\", {\n          className: \"fc-timegrid-col-events\"\n        }, _this5.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror), 'mirror')), createElement(\"div\", {\n          className: \"fc-timegrid-now-indicator-container\"\n        }, _this5.renderNowIndicator(props.nowIndicatorSegs)), hasCustomDayCellContent(options) && createElement(InnerContent, {\n          elTag: \"div\",\n          elClasses: ['fc-timegrid-col-misc']\n        }));\n      });\n    }\n  }, {\n    key: \"renderFgSegs\",\n    value: function renderFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {\n      var props = this.props;\n      if (props.forPrint) {\n        return renderPlainFgSegs(sortedFgSegs, props);\n      }\n      return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey);\n    }\n  }, {\n    key: \"renderPositionedFgSegs\",\n    value: function renderPositionedFgSegs(segs,\n    // if not mirror, needs to be sorted\n    segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {\n      var _this6 = this;\n      var _this$context$options2 = this.context.options,\n        eventMaxStack = _this$context$options2.eventMaxStack,\n        eventShortHeight = _this$context$options2.eventShortHeight,\n        eventOrderStrict = _this$context$options2.eventOrderStrict,\n        eventMinHeight = _this$context$options2.eventMinHeight;\n      var _this$props = this.props,\n        date = _this$props.date,\n        slatCoords = _this$props.slatCoords,\n        eventSelection = _this$props.eventSelection,\n        todayRange = _this$props.todayRange,\n        nowDate = _this$props.nowDate;\n      var isMirror = isDragging || isResizing || isDateSelecting;\n      var segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);\n      var _computeFgSegPlacemen = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack),\n        segPlacements = _computeFgSegPlacemen.segPlacements,\n        hiddenGroups = _computeFgSegPlacemen.hiddenGroups;\n      return createElement(Fragment, null, this.renderHiddenGroups(hiddenGroups, segs), segPlacements.map(function (segPlacement) {\n        var seg = segPlacement.seg,\n          rect = segPlacement.rect;\n        var instanceId = seg.eventRange.instance.instanceId;\n        var isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);\n        var vStyle = computeSegVStyle(rect && rect.span);\n        var hStyle = !isMirror && rect ? _this6.computeSegHStyle(rect) : {\n          left: 0,\n          right: 0\n        };\n        var isInset = Boolean(rect) && rect.stackForward > 0;\n        var isShort = Boolean(rect) && rect.span.end - rect.span.start < eventShortHeight; // look at other places for this problem\n        return createElement(\"div\", {\n          className: 'fc-timegrid-event-harness' + (isInset ? ' fc-timegrid-event-harness-inset' : ''),\n          key: forcedKey || instanceId,\n          style: Object.assign(Object.assign({\n            visibility: isVisible ? '' : 'hidden'\n          }, vStyle), hStyle)\n        }, createElement(TimeColEvent, Object.assign({\n          seg: seg,\n          isDragging: isDragging,\n          isResizing: isResizing,\n          isDateSelecting: isDateSelecting,\n          isSelected: instanceId === eventSelection,\n          isShort: isShort\n        }, getSegMeta(seg, todayRange, nowDate))));\n      }));\n    } // will already have eventMinHeight applied because segInputs already had it\n  }, {\n    key: \"renderHiddenGroups\",\n    value: function renderHiddenGroups(hiddenGroups, segs) {\n      var _this$props2 = this.props,\n        extraDateSpan = _this$props2.extraDateSpan,\n        dateProfile = _this$props2.dateProfile,\n        todayRange = _this$props2.todayRange,\n        nowDate = _this$props2.nowDate,\n        eventSelection = _this$props2.eventSelection,\n        eventDrag = _this$props2.eventDrag,\n        eventResize = _this$props2.eventResize;\n      return createElement(Fragment, null, hiddenGroups.map(function (hiddenGroup) {\n        var positionCss = computeSegVStyle(hiddenGroup.span);\n        var hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);\n        return createElement(TimeColMoreLink, {\n          key: buildIsoString(computeEarliestSegStart(hiddenSegs)),\n          hiddenSegs: hiddenSegs,\n          top: positionCss.top,\n          bottom: positionCss.bottom,\n          extraDateSpan: extraDateSpan,\n          dateProfile: dateProfile,\n          todayRange: todayRange,\n          nowDate: nowDate,\n          eventSelection: eventSelection,\n          eventDrag: eventDrag,\n          eventResize: eventResize\n        });\n      }));\n    }\n  }, {\n    key: \"renderFillSegs\",\n    value: function renderFillSegs(segs, fillType) {\n      var props = this.props,\n        context = this.context;\n      var segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight); // don't assume all populated\n      var children = segVCoords.map(function (vcoords, i) {\n        var seg = segs[i];\n        return createElement(\"div\", {\n          key: buildEventRangeKey(seg.eventRange),\n          className: \"fc-timegrid-bg-harness\",\n          style: computeSegVStyle(vcoords)\n        }, fillType === 'bg-event' ? createElement(BgEvent, Object.assign({\n          seg: seg\n        }, getSegMeta(seg, props.todayRange, props.nowDate))) : renderFill(fillType));\n      });\n      return createElement(Fragment, null, children);\n    }\n  }, {\n    key: \"renderNowIndicator\",\n    value: function renderNowIndicator(segs) {\n      var _this$props3 = this.props,\n        slatCoords = _this$props3.slatCoords,\n        date = _this$props3.date;\n      if (!slatCoords) {\n        return null;\n      }\n      return segs.map(function (seg, i) {\n        return createElement(NowIndicatorContainer\n        // key doesn't matter. will only ever be one\n        , {\n          // key doesn't matter. will only ever be one\n          key: i,\n          elClasses: ['fc-timegrid-now-indicator-line'],\n          elStyle: {\n            top: slatCoords.computeDateTop(seg.start, date)\n          },\n          isAxis: false,\n          date: date\n        });\n      });\n    }\n  }, {\n    key: \"computeSegHStyle\",\n    value: function computeSegHStyle(segHCoords) {\n      var _this$context2 = this.context,\n        isRtl = _this$context2.isRtl,\n        options = _this$context2.options;\n      var shouldOverlap = options.slotEventOverlap;\n      var nearCoord = segHCoords.levelCoord; // the left side if LTR. the right side if RTL. floating-point\n      var farCoord = segHCoords.levelCoord + segHCoords.thickness; // the right side if LTR. the left side if RTL. floating-point\n      var left; // amount of space from left edge, a fraction of the total width\n      var right; // amount of space from right edge, a fraction of the total width\n      if (shouldOverlap) {\n        // double the width, but don't go beyond the maximum forward coordinate (1.0)\n        farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);\n      }\n      if (isRtl) {\n        left = 1 - farCoord;\n        right = nearCoord;\n      } else {\n        left = nearCoord;\n        right = 1 - farCoord;\n      }\n      var props = {\n        zIndex: segHCoords.stackDepth + 1,\n        left: left * 100 + '%',\n        right: right * 100 + '%'\n      };\n      if (shouldOverlap && !segHCoords.stackForward) {\n        // add padding to the edge so that forward stacked events don't cover the resizer's icon\n        props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\n      }\n\n      return props;\n    }\n  }]);\n  return TimeCol;\n}(BaseComponent);\nfunction renderPlainFgSegs(sortedFgSegs, _ref) {\n  var todayRange = _ref.todayRange,\n    nowDate = _ref.nowDate,\n    eventSelection = _ref.eventSelection,\n    eventDrag = _ref.eventDrag,\n    eventResize = _ref.eventResize;\n  var hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) || (eventResize ? eventResize.affectedInstances : null) || {};\n  return createElement(Fragment, null, sortedFgSegs.map(function (seg) {\n    var instanceId = seg.eventRange.instance.instanceId;\n    return createElement(\"div\", {\n      key: instanceId,\n      style: {\n        visibility: hiddenInstances[instanceId] ? 'hidden' : ''\n      }\n    }, createElement(TimeColEvent, Object.assign({\n      seg: seg,\n      isDragging: false,\n      isResizing: false,\n      isDateSelecting: false,\n      isSelected: instanceId === eventSelection,\n      isShort: false\n    }, getSegMeta(seg, todayRange, nowDate))));\n  }));\n}\nfunction computeSegVStyle(segVCoords) {\n  if (!segVCoords) {\n    return {\n      top: '',\n      bottom: ''\n    };\n  }\n  return {\n    top: segVCoords.start,\n    bottom: -segVCoords.end\n  };\n}\nfunction compileSegsFromEntries(segEntries, allSegs) {\n  return segEntries.map(function (segEntry) {\n    return allSegs[segEntry.index];\n  });\n}\nvar TimeColsContent = /*#__PURE__*/function (_BaseComponent7) {\n  _inherits(TimeColsContent, _BaseComponent7);\n  function TimeColsContent() {\n    var _this7;\n    _classCallCheck(this, TimeColsContent);\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(TimeColsContent).apply(this, arguments));\n    _this7.splitFgEventSegs = memoize(splitSegsByCol);\n    _this7.splitBgEventSegs = memoize(splitSegsByCol);\n    _this7.splitBusinessHourSegs = memoize(splitSegsByCol);\n    _this7.splitNowIndicatorSegs = memoize(splitSegsByCol);\n    _this7.splitDateSelectionSegs = memoize(splitSegsByCol);\n    _this7.splitEventDrag = memoize(splitInteractionByCol);\n    _this7.splitEventResize = memoize(splitInteractionByCol);\n    _this7.rootElRef = createRef();\n    _this7.cellElRefs = new RefMap();\n    return _this7;\n  }\n  _createClass(TimeColsContent, [{\n    key: \"render\",\n    value: function render() {\n      var _this8 = this;\n      var props = this.props,\n        context = this.context;\n      var nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate); // might return void\n      var colCnt = props.cells.length;\n      var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);\n      var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);\n      var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);\n      var nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);\n      var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);\n      var eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);\n      var eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);\n      return createElement(\"div\", {\n        className: \"fc-timegrid-cols\",\n        ref: this.rootElRef\n      }, createElement(\"table\", {\n        role: \"presentation\",\n        style: {\n          minWidth: props.tableMinWidth,\n          width: props.clientWidth\n        }\n      }, props.tableColGroupNode, createElement(\"tbody\", {\n        role: \"presentation\"\n      }, createElement(\"tr\", {\n        role: \"row\"\n      }, props.axis && createElement(\"td\", {\n        \"aria-hidden\": true,\n        className: \"fc-timegrid-col fc-timegrid-axis\"\n      }, createElement(\"div\", {\n        className: \"fc-timegrid-col-frame\"\n      }, createElement(\"div\", {\n        className: \"fc-timegrid-now-indicator-container\"\n      }, typeof nowIndicatorTop === 'number' && createElement(NowIndicatorContainer, {\n        elClasses: ['fc-timegrid-now-indicator-arrow'],\n        elStyle: {\n          top: nowIndicatorTop\n        },\n        isAxis: true,\n        date: props.nowDate\n      })))), props.cells.map(function (cell, i) {\n        return createElement(TimeCol, {\n          key: cell.key,\n          elRef: _this8.cellElRefs.createRef(cell.key),\n          dateProfile: props.dateProfile,\n          date: cell.date,\n          nowDate: props.nowDate,\n          todayRange: props.todayRange,\n          extraRenderProps: cell.extraRenderProps,\n          extraDataAttrs: cell.extraDataAttrs,\n          extraClassNames: cell.extraClassNames,\n          extraDateSpan: cell.extraDateSpan,\n          fgEventSegs: fgEventSegsByRow[i],\n          bgEventSegs: bgEventSegsByRow[i],\n          businessHourSegs: businessHourSegsByRow[i],\n          nowIndicatorSegs: nowIndicatorSegsByRow[i],\n          dateSelectionSegs: dateSelectionSegsByRow[i],\n          eventDrag: eventDragByRow[i],\n          eventResize: eventResizeByRow[i],\n          slatCoords: props.slatCoords,\n          eventSelection: props.eventSelection,\n          forPrint: props.forPrint\n        });\n      })))));\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.updateCoords();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.updateCoords();\n    }\n  }, {\n    key: \"updateCoords\",\n    value: function updateCoords() {\n      var props = this.props;\n      if (props.onColCoords && props.clientWidth !== null // means sizing has stabilized\n      ) {\n        props.onColCoords(new PositionCache(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.cells), true,\n        // horizontal\n        false));\n      }\n    }\n  }]);\n  return TimeColsContent;\n}(BaseComponent);\nfunction collectCellEls(elMap, cells) {\n  return cells.map(function (cell) {\n    return elMap[cell.key];\n  });\n}\n\n/* A component that renders one or more columns of vertical time slots\n----------------------------------------------------------------------------------------------------------------------*/\nvar TimeCols = /*#__PURE__*/function (_DateComponent2) {\n  _inherits(TimeCols, _DateComponent2);\n  function TimeCols() {\n    var _this9;\n    _classCallCheck(this, TimeCols);\n    _this9 = _possibleConstructorReturn(this, _getPrototypeOf(TimeCols).apply(this, arguments));\n    _this9.processSlotOptions = memoize(processSlotOptions);\n    _this9.state = {\n      slatCoords: null\n    };\n    _this9.handleRootEl = function (el) {\n      if (el) {\n        _this9.context.registerInteractiveComponent(_assertThisInitialized(_assertThisInitialized(_this9)), {\n          el: el,\n          isHitComboAllowed: _this9.props.isHitComboAllowed\n        });\n      } else {\n        _this9.context.unregisterInteractiveComponent(_assertThisInitialized(_assertThisInitialized(_this9)));\n      }\n    };\n    _this9.handleScrollRequest = function (request) {\n      var onScrollTopRequest = _this9.props.onScrollTopRequest;\n      var slatCoords = _this9.state.slatCoords;\n      if (onScrollTopRequest && slatCoords) {\n        if (request.time) {\n          var top = slatCoords.computeTimeTop(request.time);\n          top = Math.ceil(top); // zoom can give weird floating-point values. rather scroll a little bit further\n          if (top) {\n            top += 1; // to overcome top border that slots beyond the first have. looks better\n          }\n\n          onScrollTopRequest(top);\n        }\n        return true;\n      }\n      return false;\n    };\n    _this9.handleColCoords = function (colCoords) {\n      _this9.colCoords = colCoords;\n    };\n    _this9.handleSlatCoords = function (slatCoords) {\n      _this9.setState({\n        slatCoords: slatCoords\n      });\n      if (_this9.props.onSlatCoords) {\n        _this9.props.onSlatCoords(slatCoords);\n      }\n    };\n    return _this9;\n  }\n  _createClass(TimeCols, [{\n    key: \"render\",\n    value: function render() {\n      var props = this.props,\n        state = this.state;\n      return createElement(\"div\", {\n        className: \"fc-timegrid-body\",\n        ref: this.handleRootEl,\n        style: {\n          // these props are important to give this wrapper correct dimensions for interactions\n          // TODO: if we set it here, can we avoid giving to inner tables?\n          width: props.clientWidth,\n          minWidth: props.tableMinWidth\n        }\n      }, createElement(TimeColsSlats, {\n        axis: props.axis,\n        dateProfile: props.dateProfile,\n        slatMetas: props.slatMetas,\n        clientWidth: props.clientWidth,\n        minHeight: props.expandRows ? props.clientHeight : '',\n        tableMinWidth: props.tableMinWidth,\n        tableColGroupNode: props.axis ? props.tableColGroupNode : null /* axis depends on the colgroup's shrinking */,\n        onCoords: this.handleSlatCoords\n      }), createElement(TimeColsContent, {\n        cells: props.cells,\n        axis: props.axis,\n        dateProfile: props.dateProfile,\n        businessHourSegs: props.businessHourSegs,\n        bgEventSegs: props.bgEventSegs,\n        fgEventSegs: props.fgEventSegs,\n        dateSelectionSegs: props.dateSelectionSegs,\n        eventSelection: props.eventSelection,\n        eventDrag: props.eventDrag,\n        eventResize: props.eventResize,\n        todayRange: props.todayRange,\n        nowDate: props.nowDate,\n        nowIndicatorSegs: props.nowIndicatorSegs,\n        clientWidth: props.clientWidth,\n        tableMinWidth: props.tableMinWidth,\n        tableColGroupNode: props.tableColGroupNode,\n        slatCoords: state.slatCoords,\n        onColCoords: this.handleColCoords,\n        forPrint: props.forPrint\n      }));\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.scrollResponder.detach();\n    }\n  }, {\n    key: \"queryHit\",\n    value: function queryHit(positionLeft, positionTop) {\n      var _this$context3 = this.context,\n        dateEnv = _this$context3.dateEnv,\n        options = _this$context3.options;\n      var colCoords = this.colCoords;\n      var dateProfile = this.props.dateProfile;\n      var slatCoords = this.state.slatCoords;\n      var _this$processSlotOpti = this.processSlotOptions(this.props.slotDuration, options.snapDuration),\n        snapDuration = _this$processSlotOpti.snapDuration,\n        snapsPerSlot = _this$processSlotOpti.snapsPerSlot;\n      var colIndex = colCoords.leftToIndex(positionLeft);\n      var slatIndex = slatCoords.positions.topToIndex(positionTop);\n      if (colIndex != null && slatIndex != null) {\n        var cell = this.props.cells[colIndex];\n        var slatTop = slatCoords.positions.tops[slatIndex];\n        var slatHeight = slatCoords.positions.getHeight(slatIndex);\n        var partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1\n        var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n        var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n        var dayDate = this.props.cells[colIndex].date;\n        var time = addDurations(dateProfile.slotMinTime, multiplyDuration(snapDuration, snapIndex));\n        var start = dateEnv.add(dayDate, time);\n        var end = dateEnv.add(start, snapDuration);\n        return {\n          dateProfile: dateProfile,\n          dateSpan: Object.assign({\n            range: {\n              start: start,\n              end: end\n            },\n            allDay: false\n          }, cell.extraDateSpan),\n          dayEl: colCoords.els[colIndex],\n          rect: {\n            left: colCoords.lefts[colIndex],\n            right: colCoords.rights[colIndex],\n            top: slatTop,\n            bottom: slatTop + slatHeight\n          },\n          layer: 0\n        };\n      }\n      return null;\n    }\n  }]);\n  return TimeCols;\n}(DateComponent);\nfunction processSlotOptions(slotDuration, snapDurationOverride) {\n  var snapDuration = snapDurationOverride || slotDuration;\n  var snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration);\n  if (snapsPerSlot === null) {\n    snapDuration = slotDuration;\n    snapsPerSlot = 1;\n    // TODO: say warning?\n  }\n\n  return {\n    snapDuration: snapDuration,\n    snapsPerSlot: snapsPerSlot\n  };\n}\nvar DayTimeColsSlicer = /*#__PURE__*/function (_Slicer) {\n  _inherits(DayTimeColsSlicer, _Slicer);\n  function DayTimeColsSlicer() {\n    _classCallCheck(this, DayTimeColsSlicer);\n    return _possibleConstructorReturn(this, _getPrototypeOf(DayTimeColsSlicer).apply(this, arguments));\n  }\n  _createClass(DayTimeColsSlicer, [{\n    key: \"sliceRange\",\n    value: function sliceRange(range, dayRanges) {\n      var segs = [];\n      for (var col = 0; col < dayRanges.length; col += 1) {\n        var segRange = intersectRanges(range, dayRanges[col]);\n        if (segRange) {\n          segs.push({\n            start: segRange.start,\n            end: segRange.end,\n            isStart: segRange.start.valueOf() === range.start.valueOf(),\n            isEnd: segRange.end.valueOf() === range.end.valueOf(),\n            col: col\n          });\n        }\n      }\n      return segs;\n    }\n  }]);\n  return DayTimeColsSlicer;\n}(Slicer);\nvar DayTimeCols = /*#__PURE__*/function (_DateComponent3) {\n  _inherits(DayTimeCols, _DateComponent3);\n  function DayTimeCols() {\n    var _this10;\n    _classCallCheck(this, DayTimeCols);\n    _this10 = _possibleConstructorReturn(this, _getPrototypeOf(DayTimeCols).apply(this, arguments));\n    _this10.buildDayRanges = memoize(buildDayRanges);\n    _this10.slicer = new DayTimeColsSlicer();\n    _this10.timeColsRef = createRef();\n    return _this10;\n  }\n  _createClass(DayTimeCols, [{\n    key: \"render\",\n    value: function render() {\n      var _this11 = this;\n      var props = this.props,\n        context = this.context;\n      var dateProfile = props.dateProfile,\n        dayTableModel = props.dayTableModel;\n      var _context$options = context.options,\n        nowIndicator = _context$options.nowIndicator,\n        nextDayThreshold = _context$options.nextDayThreshold;\n      var dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv);\n      // give it the first row of cells\n      // TODO: would move this further down hierarchy, but sliceNowDate needs it\n      return createElement(NowTimer, {\n        unit: nowIndicator ? 'minute' : 'day'\n      }, function (nowDate, todayRange) {\n        return createElement(TimeCols, Object.assign({\n          ref: _this11.timeColsRef\n        }, _this11.slicer.sliceProps(props, dateProfile, null, context, dayRanges), {\n          forPrint: props.forPrint,\n          axis: props.axis,\n          dateProfile: dateProfile,\n          slatMetas: props.slatMetas,\n          slotDuration: props.slotDuration,\n          cells: dayTableModel.cells[0],\n          tableColGroupNode: props.tableColGroupNode,\n          tableMinWidth: props.tableMinWidth,\n          clientWidth: props.clientWidth,\n          clientHeight: props.clientHeight,\n          expandRows: props.expandRows,\n          nowDate: nowDate,\n          nowIndicatorSegs: nowIndicator && _this11.slicer.sliceNowDate(nowDate, dateProfile, nextDayThreshold, context, dayRanges),\n          todayRange: todayRange,\n          onScrollTopRequest: props.onScrollTopRequest,\n          onSlatCoords: props.onSlatCoords\n        }));\n      });\n    }\n  }]);\n  return DayTimeCols;\n}(DateComponent);\nfunction buildDayRanges(dayTableModel, dateProfile, dateEnv) {\n  var ranges = [];\n  var _iterator5 = _createForOfIteratorHelper(dayTableModel.headerDates),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var date = _step5.value;\n      ranges.push({\n        start: dateEnv.add(date, dateProfile.slotMinTime),\n        end: dateEnv.add(date, dateProfile.slotMaxTime)\n      });\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  return ranges;\n}\n\n// potential nice values for the slot-duration and interval-duration\n// from largest to smallest\nvar STOCK_SUB_DURATIONS = [{\n  hours: 1\n}, {\n  minutes: 30\n}, {\n  minutes: 15\n}, {\n  seconds: 30\n}, {\n  seconds: 15\n}];\nfunction buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {\n  var dayStart = new Date(0);\n  var slatTime = slotMinTime;\n  var slatIterator = createDuration(0);\n  var labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);\n  var metas = [];\n  while (asRoughMs(slatTime) < asRoughMs(slotMaxTime)) {\n    var date = dateEnv.add(dayStart, slatTime);\n    var isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null;\n    metas.push({\n      date: date,\n      time: slatTime,\n      key: date.toISOString(),\n      isoTimeStr: formatIsoTimeString(date),\n      isLabeled: isLabeled\n    });\n    slatTime = addDurations(slatTime, slotDuration);\n    slatIterator = addDurations(slatIterator, slotDuration);\n  }\n  return metas;\n}\n// Computes an automatic value for slotLabelInterval\nfunction computeLabelInterval(slotDuration) {\n  var i;\n  var labelInterval;\n  var slotsPerLabel;\n  // find the smallest stock label interval that results in more than one slots-per-label\n  for (i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1) {\n    labelInterval = createDuration(STOCK_SUB_DURATIONS[i]);\n    slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration);\n    if (slotsPerLabel !== null && slotsPerLabel > 1) {\n      return labelInterval;\n    }\n  }\n  return slotDuration; // fall back\n}\nvar DayTimeColsView = /*#__PURE__*/function (_TimeColsView) {\n  _inherits(DayTimeColsView, _TimeColsView);\n  function DayTimeColsView() {\n    var _this12;\n    _classCallCheck(this, DayTimeColsView);\n    _this12 = _possibleConstructorReturn(this, _getPrototypeOf(DayTimeColsView).apply(this, arguments));\n    _this12.buildTimeColsModel = memoize(buildTimeColsModel);\n    _this12.buildSlatMetas = memoize(buildSlatMetas);\n    return _this12;\n  }\n  _createClass(DayTimeColsView, [{\n    key: \"render\",\n    value: function render() {\n      var _this13 = this;\n      var _this$context4 = this.context,\n        options = _this$context4.options,\n        dateEnv = _this$context4.dateEnv,\n        dateProfileGenerator = _this$context4.dateProfileGenerator;\n      var props = this.props;\n      var dateProfile = props.dateProfile;\n      var dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);\n      var splitProps = this.allDaySplitter.splitProps(props);\n      var slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);\n      var dayMinWidth = options.dayMinWidth;\n      var hasAttachedAxis = !dayMinWidth;\n      var hasDetachedAxis = dayMinWidth;\n      var headerContent = options.dayHeaders && createElement(DayHeader, {\n        dates: dayTableModel.headerDates,\n        dateProfile: dateProfile,\n        datesRepDistinctDays: true,\n        renderIntro: hasAttachedAxis ? this.renderHeadAxis : null\n      });\n      var allDayContent = options.allDaySlot !== false && function (contentArg) {\n        return createElement(DayTable, Object.assign({}, splitProps.allDay, {\n          dateProfile: dateProfile,\n          dayTableModel: dayTableModel,\n          nextDayThreshold: options.nextDayThreshold,\n          tableMinWidth: contentArg.tableMinWidth,\n          colGroupNode: contentArg.tableColGroupNode,\n          renderRowIntro: hasAttachedAxis ? _this13.renderTableRowAxis : null,\n          showWeekNumbers: false,\n          expandRows: false,\n          headerAlignElRef: _this13.headerElRef,\n          clientWidth: contentArg.clientWidth,\n          clientHeight: contentArg.clientHeight,\n          forPrint: props.forPrint\n        }, _this13.getAllDayMaxEventProps()));\n      };\n      var timeGridContent = function timeGridContent(contentArg) {\n        return createElement(DayTimeCols, Object.assign({}, splitProps.timed, {\n          dayTableModel: dayTableModel,\n          dateProfile: dateProfile,\n          axis: hasAttachedAxis,\n          slotDuration: options.slotDuration,\n          slatMetas: slatMetas,\n          forPrint: props.forPrint,\n          tableColGroupNode: contentArg.tableColGroupNode,\n          tableMinWidth: contentArg.tableMinWidth,\n          clientWidth: contentArg.clientWidth,\n          clientHeight: contentArg.clientHeight,\n          onSlatCoords: _this13.handleSlatCoords,\n          expandRows: contentArg.expandRows,\n          onScrollTopRequest: _this13.handleScrollTopRequest\n        }));\n      };\n      return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);\n    }\n  }]);\n  return DayTimeColsView;\n}(TimeColsView);\nfunction buildTimeColsModel(dateProfile, dateProfileGenerator) {\n  var daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n  return new DayTableModel(daySeries, false);\n}\nvar css_248z = \".fc-v-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-v-event .fc-event-main{color:var(--fc-event-text-color);height:100%}.fc-v-event .fc-event-main-frame{display:flex;flex-direction:column;height:100%}.fc-v-event .fc-event-time{flex-grow:0;flex-shrink:0;max-height:100%;overflow:hidden}.fc-v-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-height:0}.fc-v-event .fc-event-title{bottom:0;max-height:100%;overflow:hidden;top:0}.fc-v-event:not(.fc-event-start){border-top-left-radius:0;border-top-right-radius:0;border-top-width:0}.fc-v-event:not(.fc-event-end){border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-width:0}.fc-v-event.fc-event-selected:before{left:-10px;right:-10px}.fc-v-event .fc-event-resizer-start{cursor:n-resize}.fc-v-event .fc-event-resizer-end{cursor:s-resize}.fc-v-event:not(.fc-event-selected) .fc-event-resizer{height:var(--fc-event-resizer-thickness);left:0;right:0}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-start{top:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer{left:50%;margin-left:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-start{top:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc .fc-timegrid .fc-daygrid-body{z-index:2}.fc .fc-timegrid-divider{padding:0 0 2px}.fc .fc-timegrid-body{min-height:100%;position:relative;z-index:1}.fc .fc-timegrid-axis-chunk{position:relative}.fc .fc-timegrid-axis-chunk>table,.fc .fc-timegrid-slots{position:relative;z-index:1}.fc .fc-timegrid-slot{border-bottom:0;height:1.5em}.fc .fc-timegrid-slot:empty:before{content:\\\"\\\\00a0\\\"}.fc .fc-timegrid-slot-minor{border-top-style:dotted}.fc .fc-timegrid-slot-label-cushion{display:inline-block;white-space:nowrap}.fc .fc-timegrid-slot-label{vertical-align:middle}.fc .fc-timegrid-axis-cushion,.fc .fc-timegrid-slot-label-cushion{padding:0 4px}.fc .fc-timegrid-axis-frame-liquid{height:100%}.fc .fc-timegrid-axis-frame{align-items:center;display:flex;justify-content:flex-end;overflow:hidden}.fc .fc-timegrid-axis-cushion{flex-shrink:0;max-width:60px}.fc-direction-ltr .fc-timegrid-slot-label-frame{text-align:right}.fc-direction-rtl .fc-timegrid-slot-label-frame{text-align:left}.fc-liquid-hack .fc-timegrid-axis-frame-liquid{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-timegrid-col-frame{min-height:100%;position:relative}.fc-media-screen.fc-liquid-hack .fc-timegrid-col-frame{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols{bottom:0;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols>table{height:100%}.fc-media-screen .fc-timegrid-col-bg,.fc-media-screen .fc-timegrid-col-events,.fc-media-screen .fc-timegrid-now-indicator-container{left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col-bg{z-index:2}.fc .fc-timegrid-col-bg .fc-non-business{z-index:1}.fc .fc-timegrid-col-bg .fc-bg-event{z-index:2}.fc .fc-timegrid-col-bg .fc-highlight{z-index:3}.fc .fc-timegrid-bg-harness{left:0;position:absolute;right:0}.fc .fc-timegrid-col-events{z-index:3}.fc .fc-timegrid-now-indicator-container{bottom:0;overflow:hidden}.fc-direction-ltr .fc-timegrid-col-events{margin:0 2.5% 0 2px}.fc-direction-rtl .fc-timegrid-col-events{margin:0 2px 0 2.5%}.fc-timegrid-event-harness{position:absolute}.fc-timegrid-event-harness>.fc-timegrid-event{bottom:0;left:0;position:absolute;right:0;top:0}.fc-timegrid-event-harness-inset .fc-timegrid-event,.fc-timegrid-event.fc-event-mirror,.fc-timegrid-more-link{box-shadow:0 0 0 1px var(--fc-page-bg-color)}.fc-timegrid-event,.fc-timegrid-more-link{border-radius:3px;font-size:var(--fc-small-font-size)}.fc-timegrid-event{margin-bottom:1px}.fc-timegrid-event .fc-event-main{padding:1px 1px 0}.fc-timegrid-event .fc-event-time{font-size:var(--fc-small-font-size);margin-bottom:1px;white-space:nowrap}.fc-timegrid-event-short .fc-event-main-frame{flex-direction:row;overflow:hidden}.fc-timegrid-event-short .fc-event-time:after{content:\\\"\\\\00a0-\\\\00a0\\\"}.fc-timegrid-event-short .fc-event-title{font-size:var(--fc-small-font-size)}.fc-timegrid-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;margin-bottom:1px;position:absolute;z-index:9999}.fc-timegrid-more-link-inner{padding:3px 2px;top:0}.fc-direction-ltr .fc-timegrid-more-link{right:0}.fc-direction-rtl .fc-timegrid-more-link{left:0}.fc .fc-timegrid-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;border-width:1px 0 0;left:0;position:absolute;right:0;z-index:4}.fc .fc-timegrid-now-indicator-arrow{border-color:var(--fc-now-indicator-color);border-style:solid;margin-top:-5px;position:absolute;z-index:4}.fc-direction-ltr .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 0 5px 6px;left:0}.fc-direction-rtl .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 6px 5px 0;right:0}\";\ninjectStyles(css_248z);\nexport { DayTimeCols, DayTimeColsSlicer, DayTimeColsView, TimeCols, TimeColsSlatsCoords, TimeColsView, buildDayRanges, buildSlatMetas, buildTimeColsModel };","map":null,"metadata":{},"sourceType":"module"}